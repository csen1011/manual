<!DOCTYPE html>

<html lang="en">

    <head>

        <meta charset="utf-8">
        <meta name="viewport" content="initial-scale=1, width=device-width">

        <!-- https://getbootstrap.com/ -->
        <link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/css/bootstrap.min.css" integrity="sha384-gH2yIJqKdNHPEq0n4Mqa/HGKIhSkIHeL5AyhkYV8i59U5AR6csBvApHHNl/vI1Bx" rel="stylesheet">
        <script crossorigin="anonymous" integrity="sha384-A3rJD856KowSb7dwlZdYEkO39Gagi7vIsF0jrRAoQmDKKtQBHUuLZ9AsSv4jD4Xa" src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/js/bootstrap.bundle.min.js"></script>

        <!-- https://jquery.com/ -->
        <script crossorigin="anonymous" integrity="sha512-894YE6QWD5I59HgZOGReFYm4dnWc1Qt5NtvYSaNcOP+u1T9qYdvdihz0PPSiiqn/+/3e7Jo4EaG7TubfWGUrMQ==" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>

        <!-- https://fontawesome.com/ -->
        <link crossorigin="anonymous" href="https://use.fontawesome.com/releases/v5.13.0/css/all.css" integrity="sha384-Bfad6CLCknfcloXFOyFnlgtENryhrpZCe29RTifKEixXQZ38WheV+i/6YWSzkz3V" rel="stylesheet">

        <!-- https://www.ubuntu.com/ -->
        <link href="https://assets.ubuntu.com/v1/49a1a858-favicon-32x32.png" rel="icon" type="image/png">

        <link href="/static/rouge.css" rel="stylesheet">

        <script>

            

    $(function() {

        // Ensure all elements are styled the same
        $('pre').addClass('p-3');
        $('table').addClass('table');

        // Add toggles
        $('div.section').each(function(index, element) {

            // Prepare switch
            const $section = $(element);
            const id = 'switch-' + $section.attr('data-for');
            const $switch = $(
                '<div class="form-check form-switch mb-4">' +
                '<input id="' + id + '" class="form-check-input" type="checkbox">' +
                '<label class="form-check-label" for="' + id + '">less comfortable</label>' +
                '</div>'
            );

            // Find comfort levels
            const $less = $section.find('[data-less]');
            const $more = $section.find('[data-more]');

            // If a less-comfortable section exists, check it by default
            if ($less.length) {
                $switch.find('input').prop('checked', true);
            }

            // If only one comfort level exists, disable switch
            if (!$less.length || !$more.length) {
                $switch.find('input').prop('disabled', true);
            }

            // Listen for changes
            $switch.find('input').on('change', function() {
                if ($(this).is(':checked')) {
                    $less.removeClass('d-none');
                    $more.addClass('d-none');
                }
                else {
                    $less.addClass('d-none');
                    $more.removeClass('d-none');
                }
            }).trigger('change');

            // Add switch to DOM section has less-comfy level
            if ($section.find('[data-less]').length) {
                $section.prepend($switch);
            }
        });

        // Hide sections
        $('[data-hide]').each(function(index, element) {
            const $button = $('<button class="btn btn-outline-primary btn-sm" type="button">Show</button>');
            const id = $(element).attr('data-for');
            $(element).before($button);
            $button.on('click', function() {
                $(element).show();
                $(this).remove();
            });
            if (id) {
                $button.attr('data-for', id);
                $('#' + id).children('a').on('click', function() {
                    $button.trigger('click');
                });
            }
            $(element).hide();
        });

        // Show section if in hash
        $(window).on('hashchange', function() {
            const id = window.location.hash.slice(1);
            if (id) {
                $('button[data-for="' + id + '"]').trigger('click');
            }
        });
        $(window).trigger('hashchange');
    });



        </script>

        <script>

            $(function() {

                // Add borders to tables
                $('.table').addClass('table-bordered');

                // Enable popovers
                $('[data-bs-toggle="popover"]').each(function(index, element) {
                    new bootstrap.Popover(element, {
                        boundary: 'viewport',
                        html: true,
                        placement: 'bottom',
                        trigger: 'focus'
                    });
                });

                // Ensure all elements are styled the same
                $('h1').addClass('border-bottom fw-bold h2 mb-3 pb-2 pt-4');
                $('h2').addClass('fw-bold h3');

                // Ensure last heading can be anchored atop page
                $(window).resize(function() {
                    const top = $('h1').last().offset().top;
                    const margin = $(window).height() - ($('body').outerHeight() - top);
                    $('body').css('margin-bottom', Math.max(0, Math.ceil(margin)) + 'px');
                });
                $(window).trigger('resize');

                // Reveal body
                $('body').removeClass('invisible');
            });

        </script>

        <style>

            /* Style popovers */
            .popover {
                font-family: inherit;
                max-width: 100%;
            }

            /* Wrap long words (and URLs, whether linked or not), especially on mobile,
            but not in buttons and not in tables, which should instead scroll horizontally */
            * {
                word-break: break-word;
            }
            button, table * {
                word-break: normal;
            }

            /* Remove underlining */
            a {
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            nav a:hover {
                text-decoration: none;
            }

            /* Match Gmail's yellow */
            a[data-bs-toggle=popover] {
                border-bottom: 2px solid rgb(252, 237, 193);
                box-shadow: inset 0 -2px 0 rgb(252, 237, 193);
                cursor: help;
            }
            a[data-bs-toggle=popover]:hover {
                background-color: rgb(252, 237, 193);
            }

            /* Match pre tags */
            code {
                color: inherit;
            }

            /* A la Jekyll theme */
            code, pre {
                background-color: #f8f9fa;
                border: 1px solid #dee2e6;
                padding: calc(.2rem - 3px) 0.2rem;
            }
            pre code {
                background-color: initial;
                border: initial;
                padding: initial;
            }

            /* Don't shrink these */
            code, pre {
                font-size: inherit;
            }

            /* Don't italicize */
            dl dt {
                font-style: normal;
            }

            /* Don't fill viewport */
            .table {
                width: inherit;
            }

        </style>

        <style>

            

    /* Match dl and p */
    button {
        margin-bottom: 1rem;
    }

    /* Ensure syntax-highlighted code scrolls on iOS, https://stackoverflow.com/a/49592093 */
    pre code {
        white-space: pre;
        word-wrap: normal;
    }
    pre code span {
        white-space: nowrap;
    }

    

        </style>

        <title>CSEN1011 Manual Pages</title>

    </head>

    <body class="font-monospace invisible pb-5">

        <nav class="bg-dark navbar navbar-dark navbar-expand-xl px-4">
            <a class="navbar-brand" href="/"><i class="fas fa-list pe-3"></i>CSEN1011 Manual Pages</a>
        </nav>

        <div class="container-fluid mt-2 px-4">
            

    <h1 id='name'><a href='#name'>NAME</a></h1><div class='section' data-for='name'><div data-more>
<p>cgroups - Linux control groups</p>
</div></div><h1 id='description'><a href='#description'>DESCRIPTION</a></h1><div class='section' data-for='description'><div data-more>
<p>Control groups, usually referred to as cgroups, are a Linux kernel feature which allow processes to be organized into hierarchical groups whose usage of various types of resources can then be limited and monitored. The kernel's cgroup interface is provided through a pseudo-filesystem called cgroupfs. Grouping is implemented in the core cgroup kernel code, while resource tracking and limits are implemented in a set of per-resource-type subsystems (memory, CPU, and so on). A <code>cgroup</code> is a collection of processes that are bound to a set of limits or parameters defined via the cgroup filesystem.</p>
<p>A <code>subsystem</code> is a kernel component that modifies the behavior of the processes in a cgroup. Various subsystems have been implemented, making it possible to do things such as limiting the amount of CPU time and memory available to a cgroup, accounting for the CPU time used by a cgroup, and freezing and resuming execution of the processes in a cgroup. Subsystems are sometimes also known as <code>resource controllers</code> (or simply, controllers).</p>
<p>The cgroups for a controller are arranged in a <code>hierarchy</code>. This hierarchy is defined by creating, removing, and renaming subdirectories within the cgroup filesystem. At each level of the hierarchy, attributes (e.g., limits) can be defined. The limits, control, and accounting provided by cgroups generally have effect throughout the subhierarchy underneath the cgroup where the attributes are defined. Thus, for example, the limits placed on a cgroup at a higher level in the hierarchy cannot be exceeded by descendant cgroups. The initial release of the cgroups implementation was in Linux 2.6.24. Over time, various cgroup controllers have been added to allow the management of various types of resources. However, the development of these controllers was largely uncoordinated, with the result that many inconsistencies arose between controllers and management of the cgroup hierarchies became rather complex. A longer description of these problems can be found in the kernel source file <code>Documentation/admin-guide/cgroup-v2.rst</code> (or <code>Documentation/cgroup-v2.txt</code> in Linux 4.17 and earlier).</p>
<p>Because of the problems with the initial cgroups implementation (cgroups version 1), starting in Linux 3.10, work began on a new, orthogonal implementation to remedy these problems. Initially marked experimental, and hidden behind the <code>-o __DEVEL__sane_behavior</code> mount option, the new version (cgroups version 2) was eventually made official with the release of Linux 4.5. Differences between the two versions are described in the text below. The file <code>cgroup.sane_behavior</code>, present in cgroups v1, is a relic of this mount option. The file always reports "0" and is only retained for backward compatibility.</p>
<p>Although cgroups v2 is intended as a replacement for cgroups v1, the older system continues to exist (and for compatibility reasons is unlikely to be removed). Currently, cgroups v2 implements only a subset of the controllers available in cgroups v1. The two systems are implemented so that both v1 controllers and v2 controllers can be mounted on the same system. Thus, for example, it is possible to use those controllers that are supported under version 2, while also using version 1 controllers where version 2 does not yet support those controllers. The only restriction here is that a controller can't be simultaneously employed in both a cgroups v1 hierarchy and in the cgroups v2 hierarchy. Under cgroups v1, each controller may be mounted against a separate cgroup filesystem that provides its own hierarchical organization of the processes on the system. It is also possible to comount multiple (or even all) cgroups v1 controllers against the same cgroup filesystem, meaning that the comounted controllers manage the same hierarchical organization of processes.</p>
<p>For each mounted hierarchy, the directory tree mirrors the control group hierarchy. Each control group is represented by a directory, with each of its child control cgroups represented as a child directory. For instance, <code>/user/joe/1.session</code> represents control group <code>1.session</code>, which is a child of cgroup <code>joe</code>, which is a child of <code>/user</code>. Under each cgroup directory is a set of files which can be read or written to, reflecting resource limits and a few general cgroup properties. In cgroups v1, a distinction is drawn between <code>processes</code> and <code>tasks</code>. In this view, a process can consist of multiple tasks (more commonly called threads, from a user-space perspective, and called such in the remainder of this man page). In cgroups v1, it is possible to independently manipulate the cgroup memberships of the threads in a process.</p>
<p>The cgroups v1 ability to split threads across different cgroups caused problems in some cases. For example, it made no sense for the <code>memory</code> controller, since all of the threads of a process share a single address space. Because of these problems, the ability to independently manipulate the cgroup memberships of the threads in a process was removed in the initial cgroups v2 implementation, and subsequently restored in a more limited form (see the discussion of "thread mode" below). The use of cgroups requires a kernel built with the <strong>CONFIG_CGROUP</strong> option. In addition, each of the v1 controllers has an associated configuration option that must be set in order to employ that controller.</p>
<p>In order to use a v1 controller, it must be mounted against a cgroup filesystem. The usual place for such mounts is under a <a href='/5/tmpfs'>tmpfs</a>(5) filesystem mounted at <code>/sys/fs/cgroup</code>. Thus, one might mount the <code>cpu</code> controller as follows:</p>
<pre><code>mount -t cgroup -o cpu none /sys/fs/cgroup/cpu</code></pre>
<p>It is possible to comount multiple controllers against the same hierarchy. For example, here the <code>cpu</code> and <code>cpuacct</code> controllers are comounted against a single hierarchy:</p>
<pre><code>mount -t cgroup -o cpu,cpuacct none /sys/fs/cgroup/cpu,cpuacct</code></pre>
<p>Comounting controllers has the effect that a process is in the same cgroup for all of the comounted controllers. Separately mounting controllers allows a process to be in cgroup <code>/foo1</code> for one controller while being in <code>/foo2/foo3</code> for another.</p>
<p>It is possible to comount all v1 controllers against the same hierarchy:</p>
<pre><code>mount -t cgroup -o all cgroup /sys/fs/cgroup</code></pre>
<p>(One can achieve the same result by omitting <code>-o all</code>, since it is the default if no controllers are explicitly specified.)</p>
<p>It is not possible to mount the same controller against multiple cgroup hierarchies. For example, it is not possible to mount both the <code>cpu</code> and <code>cpuacct</code> controllers against one hierarchy, and to mount the <code>cpu</code> controller alone against another hierarchy. It is possible to create multiple mount points with exactly the same set of comounted controllers. However, in this case all that results is multiple mount points providing a view of the same hierarchy.</p>
<p>Note that on many systems, the v1 controllers are automatically mounted under <code>/sys/fs/cgroup</code>; in particular, <a href='/1/systemd'>systemd</a>(1) automatically creates such mount points. A mounted cgroup filesystem can be unmounted using the <a href='/8/umount'>umount</a>(8) command, as in the following example:</p>
<pre><code>umount /sys/fs/cgroup/pids</code></pre>
<p><code>But note well</code>: a cgroup filesystem is unmounted only if it is not busy, that is, it has no child cgroups. If this is not the case, then the only effect of the <a href='/8/umount'>umount</a>(8) is to make the mount invisible. Thus, to ensure that the mount point is really removed, one must first remove all child cgroups, which in turn can be done only after all member processes have been moved from those cgroups to the root cgroup. Each of the cgroups version 1 controllers is governed by a kernel configuration option (listed below). Additionally, the availability of the cgroups feature is governed by the <strong>CONFIG_CGROUPS</strong> kernel configuration option.</p>
<dl>
<dt><code>cpu</code> (since Linux 2.6.24; <code><strong>CONFIG_CGROUP_SCHED</strong></code>)</dt>
<dd><p>Cgroups can be guaranteed a minimum number of "CPU shares" when a system is busy. This does not limit a cgroup's CPU usage if the CPUs are not busy. For further information, see <code>Documentation/scheduler/sched-design-CFS.rst</code> (or <code>Documentation/scheduler/sched-design-CFS.txt</code> in Linux 5.2 and earlier).</p>
<p>In Linux 3.2, this controller was extended to provide CPU "bandwidth" control. If the kernel is configured with <strong>CONFIG_CFS_BANDWIDTH</strong>, then within each scheduling period (defined via a file in the cgroup directory), it is possible to define an upper limit on the CPU time allocated to the processes in a cgroup. This upper limit applies even if there is no other competition for the CPU. Further information can be found in the kernel source file <code>Documentation/scheduler/sched-bwc.rst</code> (or <code>Documentation/scheduler/sched-bwc.txt</code> in Linux 5.2 and earlier).</p>
</dd>
<dt><code>cpuacct</code> (since Linux 2.6.24; <code><strong>CONFIG_CGROUP_CPUACCT</strong></code>)</dt>
<dd><p>This provides accounting for CPU usage by groups of processes.</p>
<p>Further information can be found in the kernel source file <code>Documentation/admin-guide/cgroup-v1/cpuacct.rst</code> (or <code>Documentation/cgroup-v1/cpuacct.txt</code> in Linux 5.2 and earlier).</p>
</dd>
<dt><code>cpuset</code> (since Linux 2.6.24; <code><strong>CONFIG_CPUSETS</strong></code>)</dt>
<dd><p>This cgroup can be used to bind the processes in a cgroup to a specified set of CPUs and NUMA nodes.</p>
<p>Further information can be found in the kernel source file <code>Documentation/admin-guide/cgroup-v1/cpusets.rst</code> (or <code>Documentation/cgroup-v1/cpusets.txt</code> in Linux 5.2 and earlier).</p>
</dd>
<dt><code>memory</code> (since Linux 2.6.25; <code><strong>CONFIG_MEMCG</strong></code>)</dt>
<dd><p>The memory controller supports reporting and limiting of process memory, kernel memory, and swap used by cgroups.</p>
<p>Further information can be found in the kernel source file <code>Documentation/admin-guide/cgroup-v1/memory.rst</code> (or <code>Documentation/cgroup-v1/memory.txt</code> in Linux 5.2 and earlier).</p>
</dd>
<dt><code>devices</code> (since Linux 2.6.26; <code><strong>CONFIG_CGROUP_DEVICE</strong></code>)</dt>
<dd><p>This supports controlling which processes may create (mknod) devices as well as open them for reading or writing. The policies may be specified as allow-lists and deny-lists. Hierarchy is enforced, so new rules must not violate existing rules for the target or ancestor cgroups.</p>
<p>Further information can be found in the kernel source file <code>Documentation/admin-guide/cgroup-v1/devices.rst</code> (or <code>Documentation/cgroup-v1/devices.txt</code> in Linux 5.2 and earlier).</p>
</dd>
<dt><code>freezer</code> (since Linux 2.6.28; <code><strong>CONFIG_CGROUP_FREEZER</strong></code>)</dt>
<dd><p>The <code>freezer</code> cgroup can suspend and restore (resume) all processes in a cgroup. Freezing a cgroup <code>/A</code> also causes its children, for example, processes in <code>/A/B</code>, to be frozen.</p>
<p>Further information can be found in the kernel source file <code>Documentation/admin-guide/cgroup-v1/freezer-subsystem.rst</code> (or <code>Documentation/cgroup-v1/freezer-subsystem.txt</code> in Linux 5.2 and earlier).</p>
</dd>
<dt><code>net_cls</code> (since Linux 2.6.29; <code><strong>CONFIG_CGROUP_NET_CLASSID</strong></code>)</dt>
<dd><p>This places a classid, specified for the cgroup, on network packets created by a cgroup. These classids can then be used in firewall rules, as well as used to shape traffic using <a href='/8/tc'>tc</a>(8). This applies only to packets leaving the cgroup, not to traffic arriving at the cgroup.</p>
<p>Further information can be found in the kernel source file <code>Documentation/admin-guide/cgroup-v1/net_cls.rst</code> (or <code>Documentation/cgroup-v1/net_cls.txt</code> in Linux 5.2 and earlier).</p>
</dd>
<dt><code>blkio</code> (since Linux 2.6.33; <code><strong>CONFIG_BLK_CGROUP</strong></code>)</dt>
<dd><p>The <code>blkio</code> cgroup controls and limits access to specified block devices by applying IO control in the form of throttling and upper limits against leaf nodes and intermediate nodes in the storage hierarchy.</p>
<p>Two policies are available. The first is a proportional-weight time-based division of disk implemented with CFQ. This is in effect for leaf nodes using CFQ. The second is a throttling policy which specifies upper I/O rate limits on a device.</p>
<p>Further information can be found in the kernel source file <code>Documentation/admin-guide/cgroup-v1/blkio-controller.rst</code> (or <code>Documentation/cgroup-v1/blkio-controller.txt</code> in Linux 5.2 and earlier).</p>
</dd>
<dt><code>perf_event</code> (since Linux 2.6.39; <code><strong>CONFIG_CGROUP_PERF</strong></code>)</dt>
<dd><p>This controller allows <code>perf</code> monitoring of the set of processes grouped in a cgroup.</p>
<p>Further information can be found in the kernel source files</p>
</dd>
<dt><code>net_prio</code> (since Linux 3.3; <code><strong>CONFIG_CGROUP_NET_PRIO</strong></code>)</dt>
<dd><p>This allows priorities to be specified, per network interface, for cgroups.</p>
<p>Further information can be found in the kernel source file <code>Documentation/admin-guide/cgroup-v1/net_prio.rst</code> (or <code>Documentation/cgroup-v1/net_prio.txt</code> in Linux 5.2 and earlier).</p>
</dd>
<dt><code>hugetlb</code> (since Linux 3.5; <code><strong>CONFIG_CGROUP_HUGETLB</strong></code>)</dt>
<dd><p>This supports limiting the use of huge pages by cgroups.</p>
<p>Further information can be found in the kernel source file <code>Documentation/admin-guide/cgroup-v1/hugetlb.rst</code> (or <code>Documentation/cgroup-v1/hugetlb.txt</code> in Linux 5.2 and earlier).</p>
</dd>
<dt><code>pids</code> (since Linux 4.3; <code><strong>CONFIG_CGROUP_PIDS</strong></code>)</dt>
<dd><p>This controller permits limiting the number of process that may be created in a cgroup (and its descendants).</p>
<p>Further information can be found in the kernel source file <code>Documentation/admin-guide/cgroup-v1/pids.rst</code> (or <code>Documentation/cgroup-v1/pids.txt</code> in Linux 5.2 and earlier).</p>
</dd>
<dt><code>rdma</code> (since Linux 4.11; <code><strong>CONFIG_CGROUP_RDMA</strong></code>)</dt>
<dd><p>The RDMA controller permits limiting the use of RDMA/IB-specific resources per cgroup.</p>
<p>Further information can be found in the kernel source file <code>Documentation/admin-guide/cgroup-v1/rdma.rst</code> (or <code>Documentation/cgroup-v1/rdma.txt</code> in Linux 5.2 and earlier). A cgroup filesystem initially contains a single root cgroup, '/', which all processes belong to. A new cgroup is created by creating a directory in the cgroup filesystem:</p>
</dd>
</dl>
<pre><code>mkdir /sys/fs/cgroup/cpu/cg1</code></pre>
<p>This creates a new empty cgroup.</p>
<p>A process may be moved to this cgroup by writing its PID into the cgroup's <code>cgroup.procs</code> file:</p>
<pre><code>echo $$ &gt; /sys/fs/cgroup/cpu/cg1/cgroup.procs</code></pre>
<p>Only one PID at a time should be written to this file.</p>
<p>Writing the value 0 to a <code>cgroup.procs</code> file causes the writing process to be moved to the corresponding cgroup.</p>
<p>When writing a PID into the <code>cgroup.procs</code>, all threads in the process are moved into the new cgroup at once.</p>
<p>Within a hierarchy, a process can be a member of exactly one cgroup. Writing a process's PID to a <code>cgroup.procs</code> file automatically removes it from the cgroup of which it was previously a member.</p>
<p>The <code>cgroup.procs</code> file can be read to obtain a list of the processes that are members of a cgroup. The returned list of PIDs is not guaranteed to be in order. Nor is it guaranteed to be free of duplicates. (For example, a PID may be recycled while reading from the list.)</p>
<p>In cgroups v1, an individual thread can be moved to another cgroup by writing its thread ID (i.e., the kernel thread ID returned by <a href='/2/clone'>clone</a>(2) and <a href='/2/gettid'>gettid</a>(2)) to the <code>tasks</code> file in a cgroup directory. This file can be read to discover the set of threads that are members of the cgroup. To remove a cgroup, it must first have no child cgroups and contain no (nonzombie) processes. So long as that is the case, one can simply remove the corresponding directory pathname. Note that files in a cgroup directory cannot and need not be removed. Two files can be used to determine whether the kernel provides notifications when a cgroup becomes empty. A cgroup is considered to be empty when it contains no child cgroups and no member processes.</p>
<p>A special file in the root directory of each cgroup hierarchy, <code>release_agent</code>, can be used to register the pathname of a program that may be invoked when a cgroup in the hierarchy becomes empty. The pathname of the newly empty cgroup (relative to the cgroup mount point) is provided as the sole command-line argument when the <code>release_agent</code> program is invoked. The <code>release_agent</code> program might remove the cgroup directory, or perhaps repopulate it with a process.</p>
<p>The default value of the <code>release_agent</code> file is empty, meaning that no release agent is invoked.</p>
<p>The content of the <code>release_agent</code> file can also be specified via a mount option when the cgroup filesystem is mounted:</p>
<pre><code>mount -o release_agent=pathname ...</code></pre>
<p>Whether or not the <code>release_agent</code> program is invoked when a particular cgroup becomes empty is determined by the value in the <code>notify_on_release</code> file in the corresponding cgroup directory. If this file contains the value 0, then the <code>release_agent</code> program is not invoked. If it contains the value 1, the <code>release_agent</code> program is invoked. The default value for this file in the root cgroup is 0. At the time when a new cgroup is created, the value in this file is inherited from the corresponding file in the parent cgroup. In cgroups v1, it is possible to mount a cgroup hierarchy that has no attached controllers:</p>
<pre><code>mount -t cgroup -o none,name=somename none /some/mount/point</code></pre>
<p>Multiple instances of such hierarchies can be mounted; each hierarchy must have a unique name. The only purpose of such hierarchies is to track processes. (See the discussion of release notification below.) An example of this is the <code>name=systemd</code> cgroup hierarchy that is used by <a href='/1/systemd'>systemd</a>(1) to track services and user sessions.</p>
<p>Since Linux 5.0, the <code>cgroup_no_v1</code> kernel boot option (described below) can be used to disable cgroup v1 named hierarchies, by specifying <code>cgroup_no_v1=named</code>.</p>
<p>In cgroups v2, all mounted controllers reside in a single unified hierarchy. While (different) controllers may be simultaneously mounted under the v1 and v2 hierarchies, it is not possible to mount the same controller simultaneously under both the v1 and the v2 hierarchies.</p>
<p>The new behaviors in cgroups v2 are summarized here, and in some cases elaborated in the following subsections.</p>
<ol type="1">
<li><p>Cgroups v2 provides a unified hierarchy against which all controllers are mounted.</p></li>
<li><p>"Internal" processes are not permitted. With the exception of the root cgroup, processes may reside only in leaf nodes (cgroups that do not themselves contain child cgroups). The details are somewhat more subtle than this, and are described below.</p></li>
<li><p>Active cgroups must be specified via the files <code>cgroup.controllers</code> and <code>cgroup.subtree_control</code>.</p></li>
<li><p>The <code>tasks</code> file has been removed. In addition, the <code>cgroup.clone_children</code> file that is employed by the <code>cpuset</code> controller has been removed.</p></li>
<li><p>An improved mechanism for notification of empty cgroups is provided by the <code>cgroup.events</code> file.</p></li>
</ol>
<p>For more changes, see the <code>Documentation/admin-guide/cgroup-v2.rst</code> file in the kernel source (or <code>Documentation/cgroup-v2.txt</code> in Linux 4.17 and earlier).</p>
<p>Some of the new behaviors listed above saw subsequent modification with the addition in Linux 4.14 of "thread mode" (described below). In cgroups v1, the ability to mount different controllers against different hierarchies was intended to allow great flexibility for application design. In practice, though, the flexibility turned out to be less useful than expected, and in many cases added complexity. Therefore, in cgroups v2, all available controllers are mounted against a single hierarchy. The available controllers are automatically mounted, meaning that it is not necessary (or possible) to specify the controllers when mounting the cgroup v2 filesystem using a command such as the following:</p>
<pre><code>mount -t cgroup2 none /mnt/cgroup2</code></pre>
<p>A cgroup v2 controller is available only if it is not currently in use via a mount against a cgroup v1 hierarchy. Or, to put things another way, it is not possible to employ the same controller against both a v1 hierarchy and the unified v2 hierarchy. This means that it may be necessary first to unmount a v1 controller (as described above) before that controller is available in v2. Since <a href='/1/systemd'>systemd</a>(1) makes heavy use of some v1 controllers by default, it can in some cases be simpler to boot the system with selected v1 controllers disabled. To do this, specify the <code>cgroup_no_v1=list</code> option on the kernel boot command line; <code>list</code> is a comma-separated list of the names of the controllers to disable, or the word <code>all</code> to disable all v1 controllers. (This situation is correctly handled by <a href='/1/systemd'>systemd</a>(1), which falls back to operating without the specified controllers.)</p>
<p>Note that on many modern systems, <a href='/1/systemd'>systemd</a>(1) automatically mounts the <code>cgroup2</code> filesystem at <code>/sys/fs/cgroup/unified</code> during the boot process. The following options (<code>mount -o</code>) can be specified when mounting the group v2 filesystem:</p>
<dl>
<dt><code>nsdelegate</code> (since Linux 4.15)</dt>
<dd><p>Treat cgroup namespaces as delegation boundaries. For details, see below.</p>
</dd>
<dt><code>memory_localevents</code> (since Linux 5.2)</dt>
<dd><p>The <code>memory.events</code> should show statistics only for the cgroup itself, and not for any descendant cgroups. This was the behavior before Linux 5.2. Starting in Linux 5.2, the default behavior is to include statistics for descendant cgroups in <code>memory.events</code>, and this mount option can be used to revert to the legacy behavior. This option is system wide and can be set on mount or modified through remount only from the initial mount namespace; it is silently ignored in noninitial namespaces. The following controllers, documented in the kernel source file <code>Documentation/admin-guide/cgroup-v2.rst</code> (or <code>Documentation/cgroup-v2.txt</code> in Linux 4.17 and earlier), are supported in cgroups version 2:</p>
</dd>
<dt><code>cpu</code> (since Linux 4.15)</dt>
<dd><p>This is the successor to the version 1 <code>cpu</code> and <code>cpuacct</code> controllers.</p>
</dd>
<dt><code>cpuset</code> (since Linux 5.0)</dt>
<dd><p>This is the successor of the version 1 <code>cpuset</code> controller.</p>
</dd>
<dt><code>freezer</code> (since Linux 5.2)</dt>
<dd><p>This is the successor of the version 1 <code>freezer</code> controller.</p>
</dd>
<dt><code>hugetlb</code> (since Linux 5.6)</dt>
<dd><p>This is the successor of the version 1 <code>hugetlb</code> controller.</p>
</dd>
<dt><code>io</code> (since Linux 4.5)</dt>
<dd><p>This is the successor of the version 1 <code>blkio</code> controller.</p>
</dd>
<dt><code>memory</code> (since Linux 4.5)</dt>
<dd><p>This is the successor of the version 1 <code>memory</code> controller.</p>
</dd>
<dt><code>perf_event</code> (since Linux 4.11)</dt>
<dd><p>This is the same as the version 1 <code>perf_event</code> controller.</p>
</dd>
<dt><code>pids</code> (since Linux 4.5)</dt>
<dd><p>This is the same as the version 1 <code>pids</code> controller.</p>
</dd>
<dt><code>rdma</code> (since Linux 4.11)</dt>
<dd><p>This is the same as the version 1 <code>rdma</code> controller.</p>
</dd>
</dl>
<p>There is no direct equivalent of the <code>net_cls</code> and <code>net_prio</code> controllers from cgroups version 1. Instead, support has been added to <a href='/8/iptables'>iptables</a>(8) to allow eBPF filters that hook on cgroup v2 pathnames to make decisions about network traffic on a per-cgroup basis.</p>
<p>The v2 <code>devices</code> controller provides no interface files; instead, device control is gated by attaching an eBPF (<strong>BPF_CGROUP_DEVICE</strong>) program to a v2 cgroup. Each cgroup in the v2 hierarchy contains the following two files:</p>
<dl>
<dt><code>cgroup.controllers</code></dt>
<dd><p>This read-only file exposes a list of the controllers that are <code>available</code> in this cgroup. The contents of this file match the contents of the <code>cgroup.subtree_control</code> file in the parent cgroup.</p>
</dd>
<dt><code>cgroup.subtree_control</code></dt>
<dd><p>This is a list of controllers that are <code>active</code> (<code>enabled</code>) in the cgroup. The set of controllers in this file is a subset of the set in the <code>cgroup.controllers</code> of this cgroup. The set of active controllers is modified by writing strings to this file containing space-delimited controller names, each preceded by '+' (to enable a controller) or '-' (to disable a controller), as in the following example:</p>
<pre><code>echo '+pids -memory' &gt; x/y/cgroup.subtree_control</code></pre>
<p>An attempt to enable a controller that is not present in <code>cgroup.controllers</code> leads to an <strong>ENOENT</strong> error when writing to the <code>cgroup.subtree_control</code> file.</p>
</dd>
</dl>
<p>Because the list of controllers in <code>cgroup.subtree_control</code> is a subset of those <code>cgroup.controllers</code>, a controller that has been disabled in one cgroup in the hierarchy can never be re-enabled in the subtree below that cgroup.</p>
<p>A cgroup's <code>cgroup.subtree_control</code> file determines the set of controllers that are exercised in the <code>child</code> cgroups. When a controller (e.g., <code>pids</code>) is present in the <code>cgroup.subtree_control</code> file of a parent cgroup, then the corresponding controller-interface files (e.g., <code>pids.max</code>) are automatically created in the children of that cgroup and can be used to exert resource control in the child cgroups. Cgroups v2 enforces a so-called "no internal processes" rule. Roughly speaking, this rule means that, with the exception of the root cgroup, processes may reside only in leaf nodes (cgroups that do not themselves contain child cgroups). This avoids the need to decide how to partition resources between processes which are members of cgroup A and processes in child cgroups of A.</p>
<p>For instance, if cgroup <code>/cg1/cg2</code> exists, then a process may reside in <code>/cg1/cg2</code>, but not in <code>/cg1</code>. This is to avoid an ambiguity in cgroups v1 with respect to the delegation of resources between processes in <code>/cg1</code> and its child cgroups. The recommended approach in cgroups v2 is to create a subdirectory called <code>leaf</code> for any nonleaf cgroup which should contain processes, but no child cgroups. Thus, processes which previously would have gone into <code>/cg1</code> would now go into <code>/cg1/leaf</code>. This has the advantage of making explicit the relationship between processes in <code>/cg1/leaf</code> and <code>/cg1</code>'s other children.</p>
<p>The "no internal processes" rule is in fact more subtle than stated above. More precisely, the rule is that a (nonroot) cgroup can't both (1) have member processes, and (2) distribute resources into child cgroups—that is, have a nonempty <code>cgroup.subtree_control</code> file. Thus, it <code>is</code> possible for a cgroup to have both member processes and child cgroups, but before controllers can be enabled for that cgroup, the member processes must be moved out of the cgroup (e.g., perhaps into the child cgroups).</p>
<p>With the Linux 4.14 addition of "thread mode" (described below), the "no internal processes" rule has been relaxed in some cases. Each nonroot cgroup in the v2 hierarchy contains a read-only file, <code>cgroup.events</code>, whose contents are key-value pairs (delimited by newline characters, with the key and value separated by spaces) providing state information about the cgroup:</p>
<pre><code>$ cat mygrp/cgroup.events
populated 1
frozen 0</code></pre>
<p>The following keys may appear in this file:</p>
<dl>
<dt><code>populated</code></dt>
<dd><p>The value of this key is either 1, if this cgroup or any of its descendants has member processes, or otherwise 0.</p>
</dd>
<dt><code>frozen</code> (since Linux 5.2)</dt>
<dd><p>The value of this key is 1 if this cgroup is currently frozen, or 0 if it is not.</p>
</dd>
</dl>
<p>The <code>cgroup.events</code> file can be monitored, in order to receive notification when the value of one of its keys changes. Such monitoring can be done using <a href='/7/inotify'>inotify</a>(7), which notifies changes as <strong>IN_MODIFY</strong> events, or <a href='/2/poll'>poll</a>(2), which notifies changes by returning the <strong>POLLPRI</strong> and <strong>POLLERR</strong> bits in the <code>revents</code> field. Cgroups v2 provides a new mechanism for obtaining notification when a cgroup becomes empty. The cgroups v1 <code>release_agent</code> and <code>notify_on_release</code> files are removed, and replaced by the <code>populated</code> key in the <code>cgroup.events</code> file. This key either has the value 0, meaning that the cgroup (and its descendants) contain no (nonzombie) member processes, or 1, meaning that the cgroup (or one of its descendants) contains member processes.</p>
<p>The cgroups v2 release-notification mechanism offers the following advantages over the cgroups v1 <code>release_agent</code> mechanism:</p>
<ul>
<li><p>It allows for cheaper notification, since a single process can monitor multiple <code>cgroup.events</code> files (using the techniques described earlier). By contrast, the cgroups v1 mechanism requires the expense of creating a process for each notification.</p></li>
<li><p>Notification for different cgroup subhierarchies can be delegated to different processes. By contrast, the cgroups v1 mechanism allows only one release agent for an entire hierarchy. Each cgroup in the v2 hierarchy contains a read-only <code>cgroup.stat</code> file (first introduced in Linux 4.14) that consists of lines containing key-value pairs. The following keys currently appear in this file:</p></li>
</ul>
<dl>
<dt><code>nr_descendants</code></dt>
<dd><p>This is the total number of visible (i.e., living) descendant cgroups underneath this cgroup.</p>
</dd>
<dt><code>nr_dying_descendants</code></dt>
<dd><p>This is the total number of dying descendant cgroups underneath this cgroup. A cgroup enters the dying state after being deleted. It remains in that state for an undefined period (which will depend on system load) while resources are freed before the cgroup is destroyed. Note that the presence of some cgroups in the dying state is normal, and is not indicative of any problem.</p>
<p>A process can't be made a member of a dying cgroup, and a dying cgroup can't be brought back to life. Each cgroup in the v2 hierarchy contains the following files, which can be used to view and set limits on the number of descendant cgroups under that cgroup:</p>
</dd>
<dt><code>cgroup.max.depth</code> (since Linux 4.14)</dt>
<dd><p>This file defines a limit on the depth of nesting of descendant cgroups. A value of 0 in this file means that no descendant cgroups can be created. An attempt to create a descendant whose nesting level exceeds the limit fails (<code>mkdir</code>(2) fails with the error <strong>EAGAIN</strong>).</p>
<p>Writing the string <code>"max"</code> to this file means that no limit is imposed. The default value in this file is <code>"max"</code>.</p>
</dd>
<dt><code>cgroup.max.descendants</code> (since Linux 4.14)</dt>
<dd><p>This file defines a limit on the number of live descendant cgroups that this cgroup may have. An attempt to create more descendants than allowed by the limit fails (<code>mkdir</code>(2) fails with the error <strong>EAGAIN</strong>).</p>
<p>Writing the string <code>"max"</code> to this file means that no limit is imposed. The default value in this file is <code>"max"</code>. In the context of cgroups, delegation means passing management of some subtree of the cgroup hierarchy to a nonprivileged user. Cgroups v1 provides support for delegation based on file permissions in the cgroup hierarchy but with less strict containment rules than v2 (as noted below). Cgroups v2 supports delegation with containment by explicit design. The focus of the discussion in this section is on delegation in cgroups v2, with some differences for cgroups v1 noted along the way.</p>
</dd>
</dl>
<p>Some terminology is required in order to describe delegation. A <code>delegater</code> is a privileged user (i.e., root) who owns a parent cgroup. A <code>delegatee</code> is a nonprivileged user who will be granted the permissions needed to manage some subhierarchy under that parent cgroup, known as the <code>delegated subtree</code>.</p>
<p>To perform delegation, the delegater makes certain directories and files writable by the delegatee, typically by changing the ownership of the objects to be the user ID of the delegatee. Assuming that we want to delegate the hierarchy rooted at (say) <code>/dlgt_grp</code> and that there are not yet any child cgroups under that cgroup, the ownership of the following is changed to the user ID of the delegatee:</p>
<dl>
<dt><code>/dlgt_grp</code></dt>
<dd><p>Changing the ownership of the root of the subtree means that any new cgroups created under the subtree (and the files they contain) will also be owned by the delegatee.</p>
</dd>
<dt><code>/dlgt_grp/cgroup.procs</code></dt>
<dd><p>Changing the ownership of this file means that the delegatee can move processes into the root of the delegated subtree.</p>
</dd>
<dt><code>/dlgt_grp/cgroup.subtree_control</code> (cgroups v2 only)</dt>
<dd><p>Changing the ownership of this file means that the delegatee can enable controllers (that are present in <code>/dlgt_grp/cgroup.controllers</code>) in order to further redistribute resources at lower levels in the subtree. (As an alternative to changing the ownership of this file, the delegater might instead add selected controllers to this file.)</p>
</dd>
<dt><code>/dlgt_grp/cgroup.threads</code> (cgroups v2 only)</dt>
<dd><p>Changing the ownership of this file is necessary if a threaded subtree is being delegated (see the description of "thread mode", below). This permits the delegatee to write thread IDs to the file. (The ownership of this file can also be changed when delegating a domain subtree, but currently this serves no purpose, since, as described below, it is not possible to move a thread between domain cgroups by writing its thread ID to the <code>cgroup.threads</code> file.)</p>
<p>In cgroups v1, the corresponding file that should instead be delegated is the <code>tasks</code> file.</p>
</dd>
</dl>
<p>The delegater should <code>not</code> change the ownership of any of the controller interfaces files (e.g., <code>pids.max</code>, <code>memory.high</code>) in <code>dlgt_grp</code>. Those files are used from the next level above the delegated subtree in order to distribute resources into the subtree, and the delegatee should not have permission to change the resources that are distributed into the delegated subtree.</p>
<p>See also the discussion of the <code>/sys/kernel/cgroup/delegate</code> file in NOTES for information about further delegatable files in cgroups v2.</p>
<p>After the aforementioned steps have been performed, the delegatee can create child cgroups within the delegated subtree (the cgroup subdirectories and the files they contain will be owned by the delegatee) and move processes between cgroups in the subtree. If some controllers are present in <code>dlgt_grp/cgroup.subtree_control</code>, or the ownership of that file was passed to the delegatee, the delegatee can also control the further redistribution of the corresponding resources into the delegated subtree. Starting with Linux 4.13, there is a second way to perform cgroup delegation in the cgroups v2 hierarchy. This is done by mounting or remounting the cgroup v2 filesystem with the <code>nsdelegate</code> mount option. For example, if the cgroup v2 filesystem has already been mounted, we can remount it with the <code>nsdelegate</code> option as follows:</p>
<pre><code>mount -t cgroup2 -o remount,nsdelegate \
                 none /sys/fs/cgroup/unified</code></pre>
<p>The effect of this mount option is to cause cgroup namespaces to automatically become delegation boundaries. More specifically, the following restrictions apply for processes inside the cgroup namespace:</p>
<ul>
<li><p>Writes to controller interface files in the root directory of the namespace will fail with the error <strong>EPERM</strong>. Processes inside the cgroup namespace can still write to delegatable files in the root directory of the cgroup namespace such as <code>cgroup.procs</code> and <code>cgroup.subtree_control</code>, and can create subhierarchy underneath the root directory.</p></li>
<li><p>Attempts to migrate processes across the namespace boundary are denied (with the error <strong>ENOENT</strong>). Processes inside the cgroup namespace can still (subject to the containment rules described below) move processes between cgroups <code>within</code> the subhierarchy under the namespace root.</p></li>
</ul>
<p>The ability to define cgroup namespaces as delegation boundaries makes cgroup namespaces more useful. To understand why, suppose that we already have one cgroup hierarchy that has been delegated to a nonprivileged user, <code>cecilia</code>, using the older delegation technique described above. Suppose further that <code>cecilia</code> wanted to further delegate a subhierarchy under the existing delegated hierarchy. (For example, the delegated hierarchy might be associated with an unprivileged container run by <code>cecilia</code>.) Even if a cgroup namespace was employed, because both hierarchies are owned by the unprivileged user <code>cecilia</code>, the following illegitimate actions could be performed:</p>
<ul>
<li><p>A process in the inferior hierarchy could change the resource controller settings in the root directory of that hierarchy. (These resource controller settings are intended to allow control to be exercised from the <code>parent</code> cgroup; a process inside the child cgroup should not be allowed to modify them.)</p></li>
<li><p>A process inside the inferior hierarchy could move processes into and out of the inferior hierarchy if the cgroups in the superior hierarchy were somehow visible.</p></li>
</ul>
<p>Employing the <code>nsdelegate</code> mount option prevents both of these possibilities.</p>
<p>The <code>nsdelegate</code> mount option only has an effect when performed in the initial mount namespace; in other mount namespaces, the option is silently ignored.</p>
<p><code>Note</code>: On some systems, <a href='/1/systemd'>systemd</a>(1) automatically mounts the cgroup v2 filesystem. In order to experiment with the <code>nsdelegate</code> operation, it may be useful to boot the kernel with the following command-line options:</p>
<pre><code>cgroup_no_v1=all systemd.legacy_systemd_cgroup_controller</code></pre>
<p>These options cause the kernel to boot with the cgroups v1 controllers disabled (meaning that the controllers are available in the v2 hierarchy), and tells <a href='/1/systemd'>systemd</a>(1) not to mount and use the cgroup v2 hierarchy, so that the v2 hierarchy can be manually mounted with the desired options after boot-up. Some delegation <code>containment rules</code> ensure that the delegatee can move processes between cgroups within the delegated subtree, but can't move processes from outside the delegated subtree into the subtree or vice versa. A nonprivileged process (i.e., the delegatee) can write the PID of a "target" process into a <code>cgroup.procs</code> file only if all of the following are true:</p>
<ul>
<li><p>The writer has write permission on the <code>cgroup.procs</code> file in the destination cgroup.</p></li>
<li><p>The writer has write permission on the <code>cgroup.procs</code> file in the nearest common ancestor of the source and destination cgroups. Note that in some cases, the nearest common ancestor may be the source or destination cgroup itself. This requirement is not enforced for cgroups v1 hierarchies, with the consequence that containment in v1 is less strict than in v2. (For example, in cgroups v1 the user that owns two distinct delegated subhierarchies can move a process between the hierarchies.)</p></li>
<li><p>If the cgroup v2 filesystem was mounted with the <code>nsdelegate</code> option, the writer must be able to see the source and destination cgroups from its cgroup namespace.</p></li>
<li><p>In cgroups v1: the effective UID of the writer (i.e., the delegatee) matches the real user ID or the saved set-user-ID of the target process. Before Linux 4.11, this requirement also applied in cgroups v2 (This was a historical requirement inherited from cgroups v1 that was later deemed unnecessary, since the other rules suffice for containment in cgroups v2.)</p></li>
</ul>
<p><code>Note</code>: one consequence of these delegation containment rules is that the unprivileged delegatee can't place the first process into the delegated subtree; instead, the delegater must place the first process (a process owned by the delegatee) into the delegated subtree. Among the restrictions imposed by cgroups v2 that were not present in cgroups v1 are the following:</p>
<ul>
<li><p><code>No thread-granularity control</code>: all of the threads of a process must be in the same cgroup.</p></li>
<li><p><code>No internal processes</code>: a cgroup can't both have member processes and exercise controllers on child cgroups.</p></li>
</ul>
<p>Both of these restrictions were added because the lack of these restrictions had caused problems in cgroups v1. In particular, the cgroups v1 ability to allow thread-level granularity for cgroup membership made no sense for some controllers. (A notable example was the <code>memory</code> controller: since threads share an address space, it made no sense to split threads across different <code>memory</code> cgroups.)</p>
<p>Notwithstanding the initial design decision in cgroups v2, there were use cases for certain controllers, notably the <code>cpu</code> controller, for which thread-level granularity of control was meaningful and useful. To accommodate such use cases, Linux 4.14 added <code>thread mode</code> for cgroups v2.</p>
<p>Thread mode allows the following:</p>
<ul>
<li><p>The creation of <code>threaded subtrees</code> in which the threads of a process may be spread across cgroups inside the tree. (A threaded subtree may contain multiple multithreaded processes.)</p></li>
<li><p>The concept of <code>threaded controllers</code>, which can distribute resources across the cgroups in a threaded subtree.</p></li>
<li><p>A relaxation of the "no internal processes rule", so that, within a threaded subtree, a cgroup can both contain member threads and exercise resource control over child cgroups.</p></li>
</ul>
<p>With the addition of thread mode, each nonroot cgroup now contains a new file, <code>cgroup.type</code>, that exposes, and in some circumstances can be used to change, the "type" of a cgroup. This file contains one of the following type values:</p>
<dl>
<dt><code>domain</code></dt>
<dd><p>This is a normal v2 cgroup that provides process-granularity control. If a process is a member of this cgroup, then all threads of the process are (by definition) in the same cgroup. This is the default cgroup type, and provides the same behavior that was provided for cgroups in the initial cgroups v2 implementation.</p>
</dd>
<dt><code>threaded</code></dt>
<dd><p>This cgroup is a member of a threaded subtree. Threads can be added to this cgroup, and controllers can be enabled for the cgroup.</p>
</dd>
<dt><code>domain threaded</code></dt>
<dd><p>This is a domain cgroup that serves as the root of a threaded subtree. This cgroup type is also known as "threaded root".</p>
</dd>
<dt><code>domain invalid</code></dt>
<dd><p>This is a cgroup inside a threaded subtree that is in an "invalid" state. Processes can't be added to the cgroup, and controllers can't be enabled for the cgroup. The only thing that can be done with this cgroup (other than deleting it) is to convert it to a <code>threaded</code> cgroup by writing the string <code>"threaded"</code> to the <code>cgroup.type</code> file.</p>
<p>The rationale for the existence of this "interim" type during the creation of a threaded subtree (rather than the kernel simply immediately converting all cgroups under the threaded root to the type <code>threaded</code>) is to allow for possible future extensions to the thread mode model With the addition of threads mode, cgroups v2 now distinguishes two types of resource controllers:</p>
</dd>
</dl>
<ul>
<li><p><code>Threaded</code> controllers: these controllers support thread-granularity for resource control and can be enabled inside threaded subtrees, with the result that the corresponding controller-interface files appear inside the cgroups in the threaded subtree. As at Linux 4.19, the following controllers are threaded: <code>cpu</code>, <code>perf_event</code>, and <code>pids</code>.</p></li>
<li><p><code>Domain</code> controllers: these controllers support only process granularity for resource control. From the perspective of a domain controller, all threads of a process are always in the same cgroup. Domain controllers can't be enabled inside a threaded subtree. There are two pathways that lead to the creation of a threaded subtree. The first pathway proceeds as follows:</p></li>
</ul>
<ol type="1">
<li><p>We write the string <code>"threaded"</code> to the <code>cgroup.type</code> file of a cgroup <code>y/z</code> that currently has the type <code>domain</code>. This has the following effects:</p>
<ul>
<li><p>The type of the cgroup <code>y/z</code> becomes <code>threaded</code>.</p></li>
<li><p>The type of the parent cgroup, <code>y</code>, becomes <code>domain threaded</code>. The parent cgroup is the root of a threaded subtree (also known as the "threaded root").</p></li>
<li><p>All other cgroups under <code>y</code> that were not already of type <code>threaded</code> (because they were inside already existing threaded subtrees under the new threaded root) are converted to type <code>domain invalid</code>. Any subsequently created cgroups under <code>y</code> will also have the type <code>domain invalid</code>.</p></li>
</ul></li>
<li><p>We write the string <code>"threaded"</code> to each of the <code>domain invalid</code> cgroups under <code>y</code>, in order to convert them to the type <code>threaded</code>. As a consequence of this step, all threads under the threaded root now have the type <code>threaded</code> and the threaded subtree is now fully usable. The requirement to write <code>"threaded"</code> to each of these cgroups is somewhat cumbersome, but allows for possible future extensions to the thread-mode model.</p></li>
</ol>
<p>The second way of creating a threaded subtree is as follows:</p>
<ol type="1">
<li><p>In an existing cgroup, <code>z</code>, that currently has the type <code>domain</code>, we (1) enable one or more threaded controllers and (2) make a process a member of <code>z</code>. (These two steps can be done in either order.) This has the following consequences:</p>
<ul>
<li><p>The type of <code>z</code> becomes <code>domain threaded</code>.</p></li>
<li><p>All of the descendant cgroups of <code>x</code> that were not already of type <code>threaded</code> are converted to type <code>domain invalid</code>.</p></li>
</ul></li>
<li><p>As before, we make the threaded subtree usable by writing the string <code>"threaded"</code> to each of the <code>domain invalid</code> cgroups under <code>y</code>, in order to convert them to the type <code>threaded</code>.</p></li>
</ol>
<p>One of the consequences of the above pathways to creating a threaded subtree is that the threaded root cgroup can be a parent only to <code>threaded</code> (and <code>domain invalid</code>) cgroups. The threaded root cgroup can't be a parent of a <code>domain</code> cgroups, and a <code>threaded</code> cgroup can't have a sibling that is a <code>domain</code> cgroup. Within a threaded subtree, threaded controllers can be enabled in each subgroup whose type has been changed to <code>threaded</code>; upon doing so, the corresponding controller interface files appear in the children of that cgroup.</p>
<p>A process can be moved into a threaded subtree by writing its PID to the <code>cgroup.procs</code> file in one of the cgroups inside the tree. This has the effect of making all of the threads in the process members of the corresponding cgroup and makes the process a member of the threaded subtree. The threads of the process can then be spread across the threaded subtree by writing their thread IDs (see <a href='/2/gettid'>gettid</a>(2)) to the <code>cgroup.threads</code> files in different cgroups inside the subtree. The threads of a process must all reside in the same threaded subtree.</p>
<p>As with writing to <code>cgroup.procs</code>, some containment rules apply when writing to the <code>cgroup.threads</code> file:</p>
<ul>
<li><p>The writer must have write permission on the cgroup.threads file in the destination cgroup.</p></li>
<li><p>The writer must have write permission on the <code>cgroup.procs</code> file in the common ancestor of the source and destination cgroups. (In some cases, the common ancestor may be the source or destination cgroup itself.)</p></li>
<li><p>The source and destination cgroups must be in the same threaded subtree. (Outside a threaded subtree, an attempt to move a thread by writing its thread ID to the <code>cgroup.threads</code> file in a different <code>domain</code> cgroup fails with the error <strong>EOPNOTSUPP</strong>.)</p></li>
</ul>
<p>The <code>cgroup.threads</code> file is present in each cgroup (including <code>domain</code> cgroups) and can be read in order to discover the set of threads that is present in the cgroup. The set of thread IDs obtained when reading this file is not guaranteed to be ordered or free of duplicates.</p>
<p>The <code>cgroup.procs</code> file in the threaded root shows the PIDs of all processes that are members of the threaded subtree. The <code>cgroup.procs</code> files in the other cgroups in the subtree are not readable.</p>
<p>Domain controllers can't be enabled in a threaded subtree; no controller-interface files appear inside the cgroups underneath the threaded root. From the point of view of a domain controller, threaded subtrees are invisible: a multithreaded process inside a threaded subtree appears to a domain controller as a process that resides in the threaded root cgroup.</p>
<p>Within a threaded subtree, the "no internal processes" rule does not apply: a cgroup can both contain member processes (or thread) and exercise controllers on child cgroups. A number of rules apply when writing to the <code>cgroup.type</code> file:</p>
<ul>
<li><p>Only the string <code>"threaded"</code> may be written. In other words, the only explicit transition that is possible is to convert a <code>domain</code> cgroup to type <code>threaded</code>.</p></li>
<li><p>The effect of writing <code>"threaded"</code> depends on the current value in <code>cgroup.type</code>, as follows:</p>
<ul>
<li><p><code>domain</code> or <code>domain threaded</code>: start the creation of a threaded subtree (whose root is the parent of this cgroup) via the first of the pathways described above;</p></li>
<li><p><code>domain invalid</code>: convert this cgroup (which is inside a threaded subtree) to a usable (i.e., <code>threaded</code>) state;</p></li>
<li><p><code>threaded</code>: no effect (a "no-op").</p></li>
</ul></li>
<li><p>We can't write to a <code>cgroup.type</code> file if the parent's type is <code>domain invalid</code>. In other words, the cgroups of a threaded subtree must be converted to the <code>threaded</code> state in a top-down manner.</p></li>
</ul>
<p>There are also some constraints that must be satisfied in order to create a threaded subtree rooted at the cgroup <code>x</code>:</p>
<ul>
<li><p>There can be no member processes in the descendant cgroups of <code>x</code>. (The cgroup <code>x</code> can itself have member processes.)</p></li>
<li><p>No domain controllers may be enabled in <code>x</code>'s <code>cgroup.subtree_control</code> file.</p></li>
</ul>
<p>If any of the above constraints is violated, then an attempt to write <code>"threaded"</code> to a <code>cgroup.type</code> file fails with the error <strong>ENOTSUP</strong>. According to the pathways described above, the type of a cgroup can change to <code>domain threaded</code> in either of the following cases:</p>
<ul>
<li><p>The string <code>"threaded"</code> is written to a child cgroup.</p></li>
<li><p>A threaded controller is enabled inside the cgroup and a process is made a member of the cgroup.</p></li>
</ul>
<p>A <code>domain threaded</code> cgroup, <code>x</code>, can revert to the type <code>domain</code> if the above conditions no longer hold true—that is, if all <code>threaded</code> child cgroups of <code>x</code> are removed and either <code>x</code> no longer has threaded controllers enabled or no longer has member processes.</p>
<p>When a <code>domain threaded</code> cgroup <code>x</code> reverts to the type <code>domain</code>:</p>
<ul>
<li><p>All <code>domain invalid</code> descendants of <code>x</code> that are not in lower-level threaded subtrees revert to the type <code>domain</code>.</p></li>
<li><p>The root cgroups in any lower-level threaded subtrees revert to the type <code>domain threaded</code>. The root cgroup of the v2 hierarchy is treated exceptionally: it can be the parent of both <code>domain</code> and <code>threaded</code> cgroups. If the string <code>"threaded"</code> is written to the <code>cgroup.type</code> file of one of the children of the root cgroup, then</p></li>
<li><p>The type of that cgroup becomes <code>threaded</code>.</p></li>
<li><p>The type of any descendants of that cgroup that are not part of lower-level threaded subtrees changes to <code>domain invalid</code>.</p></li>
</ul>
<p>Note that in this case, there is no cgroup whose type becomes <code>domain threaded</code>. (Notionally, the root cgroup can be considered as the threaded root for the cgroup whose type was changed to <code>threaded</code>.)</p>
<p>The aim of this exceptional treatment for the root cgroup is to allow a threaded cgroup that employs the <code>cpu</code> controller to be placed as high as possible in the hierarchy, so as to minimize the (small) cost of traversing the cgroup hierarchy. As at Linux 4.19, the cgroups v2 <code>cpu</code> controller does not support control of realtime threads (specifically threads scheduled under any of the policies <strong>SCHED_FIFO</strong>, <strong>SCHED_RR</strong>, described <strong>SCHED_DEADLINE</strong>; see <a href='/7/sched'>sched</a>(7)). Therefore, the <code>cpu</code> controller can be enabled in the root cgroup only if all realtime threads are in the root cgroup. (If there are realtime threads in nonroot cgroups, then a <a href='/2/write'>write</a>(2) of the string <code>"+cpu"</code> to the <code>cgroup.subtree_control</code> file fails with the error <strong>EINVAL</strong>.)</p>
<p>On some systems, <a href='/1/systemd'>systemd</a>(1) places certain realtime threads in nonroot cgroups in the v2 hierarchy. On such systems, these threads must first be moved to the root cgroup before the <code>cpu</code> controller can be enabled. The following errors can occur for <a href='/2/mount'>mount</a>(2):</p>
<dl>
<dt><strong>EBUSY</strong></dt>
<dd><p>An attempt to mount a cgroup version 1 filesystem specified neither the <code>name=</code> option (to mount a named hierarchy) nor a controller name (or <code>all</code>).</p>
</dd>
</dl>
</div></div><h1 id='notes'><a href='#notes'>NOTES</a></h1><div data-for='notes' data-hide><div class='section' data-for='notes'><div data-more>
<p>A child process created via <a href='/2/fork'>fork</a>(2) inherits its parent's cgroup memberships. A process's cgroup memberships are preserved across <a href='/2/execve'>execve</a>(2).</p>
<p>The <a href='/2/clone3'>clone3</a>(2) <strong>CLONE_INTO_CGROUP</strong> flag can be used to create a child process that begins its life in a different version 2 cgroup from the parent process.</p>
<dl>
<dt><code>/proc/cgroups</code> (since Linux 2.6.24)</dt>
<dd><p>This file contains information about the controllers that are compiled into the kernel. An example of the contents of this file (reformatted for readability) is the following:</p>
<pre><code>#subsys_name    hierarchy      num_cgroups    enabled
cpuset          4              1              1
cpu             8              1              1
cpuacct         8              1              1
blkio           6              1              1
memory          3              1              1
devices         10             84             1
freezer         7              1              1
net_cls         9              1              1
perf_event      5              1              1
net_prio        9              1              1
hugetlb         0              1              0
pids            2              1              1</code></pre>
<p>The fields in this file are, from left to right:</p>
<ol type="1">
<li><p>The name of the controller.</p></li>
<li><p>The unique ID of the cgroup hierarchy on which this controller is mounted. If multiple cgroups v1 controllers are bound to the same hierarchy, then each will show the same hierarchy ID in this field. The value in this field will be 0 if:</p>
<ol type="a">
<li><p>the controller is not mounted on a cgroups v1 hierarchy;</p></li>
<li><p>the controller is bound to the cgroups v2 single unified hierarchy; or</p></li>
<li><p>the controller is disabled (see below).</p></li>
</ol></li>
<li><p>The number of control groups in this hierarchy using this controller.</p></li>
<li><p>This field contains the value 1 if this controller is enabled, or 0 if it has been disabled (via the <code>cgroup_disable</code> kernel command-line boot parameter).</p></li>
</ol>
</dd>
<dt><code>/proc/[pid]/cgroup</code> (since Linux 2.6.24)</dt>
<dd><p>This file describes control groups to which the process with the corresponding PID belongs. The displayed information differs for cgroups version 1 and version 2 hierarchies.</p>
<p>For each cgroup hierarchy of which the process is a member, there is one entry containing three colon-separated fields:</p>
<pre><code>hierarchy-ID:controller-list:cgroup-path</code></pre>
<p>For example:</p>
<pre><code>5:cpuacct,cpu,cpuset:/daemons</code></pre>
<p>The colon-separated fields are, from left to right:</p>
<ol type="1">
<li><p>For cgroups version 1 hierarchies, this field contains a unique hierarchy ID number that can be matched to a hierarchy ID in <code>/proc/cgroups</code>. For the cgroups version 2 hierarchy, this field contains the value 0.</p></li>
<li><p>For cgroups version 1 hierarchies, this field contains a comma-separated list of the controllers bound to the hierarchy. For the cgroups version 2 hierarchy, this field is empty.</p></li>
<li><p>This field contains the pathname of the control group in the hierarchy to which the process belongs. This pathname is relative to the mount point of the hierarchy.</p></li>
</ol>
</dd>
<dt><code>/sys/kernel/cgroup/delegate</code> (since Linux 4.15)</dt>
<dd><p>This file exports a list of the cgroups v2 files (one per line) that are delegatable (i.e., whose ownership should be changed to the user ID of the delegatee). In the future, the set of delegatable files may change or grow, and this file provides a way for the kernel to inform user-space applications of which files must be delegated. As at Linux 4.15, one sees the following when inspecting this file:</p>
<pre><code>$ cat /sys/kernel/cgroup/delegate
cgroup.procs
cgroup.subtree_control
cgroup.threads</code></pre>
</dd>
<dt><code>/sys/kernel/cgroup/features</code> (since Linux 4.15)</dt>
<dd><p>Over time, the set of cgroups v2 features that are provided by the kernel may change or grow, or some features may not be enabled by default. This file provides a way for user-space applications to discover what features the running kernel supports and has enabled. Features are listed one per line:</p>
<pre><code>$ cat /sys/kernel/cgroup/features
nsdelegate
memory_localevents</code></pre>
<p>The entries that can appear in this file are:</p>
<dl>
<dt><code>memory_localevents</code> (since Linux 5.2)</dt>
<dd><p>The kernel supports the <code>memory_localevents</code> mount option.</p>
</dd>
<dt><code>nsdelegate</code> (since Linux 4.15)</dt>
<dd><p>The kernel supports the <code>nsdelegate</code> mount option.</p>
</dd>
</dl>
</dd>
</dl>
</div></div></div><h1 id='see-also'><a href='#see-also'>SEE ALSO</a></h1><div class='section' data-for='see-also'><div data-more>
<p><a href='/1/prlimit'>prlimit</a>(1), <a href='/1/systemd'>systemd</a>(1), <a href='/1/systemd-cgls'>systemd-cgls</a>(1), <a href='/1/systemd-cgtop'>systemd-cgtop</a>(1), <a href='/2/clone'>clone</a>(2), <a href='/2/ioprio_set'>ioprio_set</a>(2), <a href='/2/perf_event_open'>perf_event_open</a>(2), <a href='/2/setrlimit'>setrlimit</a>(2), <a href='/7/cgroup_namespaces'>cgroup_namespaces</a>(7), <a href='/7/cpuset'>cpuset</a>(7), <a href='/7/namespaces'>namespaces</a>(7), <a href='/7/sched'>sched</a>(7), <a href='/7/user_namespaces'>user_namespaces</a>(7)</p>
<p>The kernel source file <code>Documentation/admin-guide/cgroup-v2.rst</code>.</p>
</div></div><h1 id='colophon'><a href='#colophon'>COLOPHON</a></h1><div data-for='colophon' data-hide><div class='section' data-for='colophon'><div data-more>
<p>This page is part of release 5.10 of the Linux <code>man-pages</code> project. A description of the project, information about reporting bugs, and the latest version of this page, can be found at <a href="https://www.kernel.org/doc/man-pages/">https://www.kernel.org/doc/man-pages/</a>.</p></div></div></div>


        </div>

    </body>

</html>