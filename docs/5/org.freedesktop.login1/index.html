<!DOCTYPE html>

<html lang="en">

    <head>

        <meta charset="utf-8">
        <meta name="viewport" content="initial-scale=1, width=device-width">

        <!-- https://getbootstrap.com/ -->
        <link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/css/bootstrap.min.css" integrity="sha384-gH2yIJqKdNHPEq0n4Mqa/HGKIhSkIHeL5AyhkYV8i59U5AR6csBvApHHNl/vI1Bx" rel="stylesheet">
        <script crossorigin="anonymous" integrity="sha384-A3rJD856KowSb7dwlZdYEkO39Gagi7vIsF0jrRAoQmDKKtQBHUuLZ9AsSv4jD4Xa" src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/js/bootstrap.bundle.min.js"></script>

        <!-- https://jquery.com/ -->
        <script crossorigin="anonymous" integrity="sha512-894YE6QWD5I59HgZOGReFYm4dnWc1Qt5NtvYSaNcOP+u1T9qYdvdihz0PPSiiqn/+/3e7Jo4EaG7TubfWGUrMQ==" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>

        <!-- https://fontawesome.com/ -->
        <link crossorigin="anonymous" href="https://use.fontawesome.com/releases/v5.13.0/css/all.css" integrity="sha384-Bfad6CLCknfcloXFOyFnlgtENryhrpZCe29RTifKEixXQZ38WheV+i/6YWSzkz3V" rel="stylesheet">

        <!-- https://www.ubuntu.com/ -->
        <link href="https://assets.ubuntu.com/v1/49a1a858-favicon-32x32.png" rel="icon" type="image/png">

        <link href="/static/rouge.css" rel="stylesheet">

        <script>

            

    $(function() {

        // Ensure all elements are styled the same
        $('pre').addClass('p-3');
        $('table').addClass('table');

        // Add toggles
        $('div.section').each(function(index, element) {

            // Prepare switch
            const $section = $(element);
            const id = 'switch-' + $section.attr('data-for');
            const $switch = $(
                '<div class="form-check form-switch mb-4">' +
                '<input id="' + id + '" class="form-check-input" type="checkbox">' +
                '<label class="form-check-label" for="' + id + '">less comfortable</label>' +
                '</div>'
            );

            // Find comfort levels
            const $less = $section.find('[data-less]');
            const $more = $section.find('[data-more]');

            // If a less-comfortable section exists, check it by default
            if ($less.length) {
                $switch.find('input').prop('checked', true);
            }

            // If only one comfort level exists, disable switch
            if (!$less.length || !$more.length) {
                $switch.find('input').prop('disabled', true);
            }

            // Listen for changes
            $switch.find('input').on('change', function() {
                if ($(this).is(':checked')) {
                    $less.removeClass('d-none');
                    $more.addClass('d-none');
                }
                else {
                    $less.addClass('d-none');
                    $more.removeClass('d-none');
                }
            }).trigger('change');

            // Add switch to DOM section has less-comfy level
            if ($section.find('[data-less]').length) {
                $section.prepend($switch);
            }
        });

        // Hide sections
        $('[data-hide]').each(function(index, element) {
            const $button = $('<button class="btn btn-outline-primary btn-sm" type="button">Show</button>');
            const id = $(element).attr('data-for');
            $(element).before($button);
            $button.on('click', function() {
                $(element).show();
                $(this).remove();
            });
            if (id) {
                $button.attr('data-for', id);
                $('#' + id).children('a').on('click', function() {
                    $button.trigger('click');
                });
            }
            $(element).hide();
        });

        // Show section if in hash
        $(window).on('hashchange', function() {
            const id = window.location.hash.slice(1);
            if (id) {
                $('button[data-for="' + id + '"]').trigger('click');
            }
        });
        $(window).trigger('hashchange');
    });



        </script>

        <script>

            $(function() {

                // Add borders to tables
                $('.table').addClass('table-bordered');

                // Enable popovers
                $('[data-bs-toggle="popover"]').each(function(index, element) {
                    new bootstrap.Popover(element, {
                        boundary: 'viewport',
                        html: true,
                        placement: 'bottom',
                        trigger: 'focus'
                    });
                });

                // Ensure all elements are styled the same
                $('h1').addClass('border-bottom fw-bold h2 mb-3 pb-2 pt-4');
                $('h2').addClass('fw-bold h3');

                // Ensure last heading can be anchored atop page
                $(window).resize(function() {
                    const top = $('h1').last().offset().top;
                    const margin = $(window).height() - ($('body').outerHeight() - top);
                    $('body').css('margin-bottom', Math.max(0, Math.ceil(margin)) + 'px');
                });
                $(window).trigger('resize');

                // Reveal body
                $('body').removeClass('invisible');
            });

        </script>

        <style>

            /* Style popovers */
            .popover {
                font-family: inherit;
                max-width: 100%;
            }

            /* Wrap long words (and URLs, whether linked or not), especially on mobile,
            but not in buttons and not in tables, which should instead scroll horizontally */
            * {
                word-break: break-word;
            }
            button, table * {
                word-break: normal;
            }

            /* Remove underlining */
            a {
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            nav a:hover {
                text-decoration: none;
            }

            /* Match Gmail's yellow */
            a[data-bs-toggle=popover] {
                border-bottom: 2px solid rgb(252, 237, 193);
                box-shadow: inset 0 -2px 0 rgb(252, 237, 193);
                cursor: help;
            }
            a[data-bs-toggle=popover]:hover {
                background-color: rgb(252, 237, 193);
            }

            /* Match pre tags */
            code {
                color: inherit;
            }

            /* A la Jekyll theme */
            code, pre {
                background-color: #f8f9fa;
                border: 1px solid #dee2e6;
                padding: calc(.2rem - 3px) 0.2rem;
            }
            pre code {
                background-color: initial;
                border: initial;
                padding: initial;
            }

            /* Don't shrink these */
            code, pre {
                font-size: inherit;
            }

            /* Don't italicize */
            dl dt {
                font-style: normal;
            }

            /* Don't fill viewport */
            .table {
                width: inherit;
            }

        </style>

        <style>

            

    /* Match dl and p */
    button {
        margin-bottom: 1rem;
    }

    /* Ensure syntax-highlighted code scrolls on iOS, https://stackoverflow.com/a/49592093 */
    pre code {
        white-space: pre;
        word-wrap: normal;
    }
    pre code span {
        white-space: nowrap;
    }

    

        </style>

        <title>CSEN1011 Manual Pages</title>

    </head>

    <body class="font-monospace invisible pb-5">

        <nav class="bg-dark navbar navbar-dark navbar-expand-xl px-4">
            <a class="navbar-brand" href="/"><i class="fas fa-list pe-3"></i>CSEN1011 Manual Pages</a>
        </nav>

        <div class="container-fluid mt-2 px-4">
            

    <h1 id='name'><a href='#name'>NAME</a></h1><div class='section' data-for='name'><div data-more>
<p>org.freedesktop.login1 - The D-Bus interface of systemd-logind</p>
</div></div><h1 id='introduction'><a href='#introduction'>INTRODUCTION</a></h1><div data-for='introduction' data-hide><div class='section' data-for='introduction'><div data-more>
<p><a href='/8/systemd-logind.service'>systemd-logind.service</a>(8) is a system service that keeps track of user logins and seats.</p>
<p>The daemon provides both a C library interface as well as a D-Bus interface. The library interface may be used to introspect and watch the state of user logins and seats. The bus interface provides the same functionality but in addition may also be used to make changes to the system state. For more information please consult <a href='/3/sd-login'>sd-login</a>(3).</p>
</div></div></div><h1 id='the-manager-object'><a href='#the-manager-object'>THE MANAGER OBJECT</a></h1><div data-for='the-manager-object' data-hide><div class='section' data-for='the-manager-object'><div data-more>
<p>The service exposes the following interfaces on the Manager object on the bus:</p>
<p>.RS 4</p>
<pre><code>node /org/freedesktop/login1 {
  interface org.freedesktop.login1.Manager {
    methods:
      GetSession(in  s session_id,
                 out o object_path);
      GetSessionByPID(in  u pid,
                      out o object_path);
      GetUser(in  u uid,
              out o object_path);
      GetUserByPID(in  u pid,
                   out o object_path);
      GetSeat(in  s seat_id,
              out o object_path);
      ListSessions(out a(susso) sessions);
      ListUsers(out a(uso) users);
      ListSeats(out a(so) seats);
      ListInhibitors(out a(ssssuu) inhibitors);
      CreateSession(in  u uid,
                    in  u pid,
                    in  s service,
                    in  s type,
                    in  s class,
                    in  s desktop,
                    in  s seat_id,
                    in  u vtnr,
                    in  s tty,
                    in  s display,
                    in  b remote,
                    in  s remote_user,
                    in  s remote_host,
                    in  a(sv) properties,
                    out s session_id,
                    out o object_path,
                    out s runtime_path,
                    out h fifo_fd,
                    out u uid,
                    out s seat_id,
                    out u vtnr,
                    out b existing);
      ReleaseSession(in  s session_id);
      ActivateSession(in  s session_id);
      ActivateSessionOnSeat(in  s session_id,
                            in  s seat_id);
      LockSession(in  s session_id);
      UnlockSession(in  s session_id);
      LockSessions();
      UnlockSessions();
      KillSession(in  s session_id,
                  in  s who,
                  in  i signal_number);
      KillUser(in  u uid,
               in  i signal_number);
      TerminateSession(in  s session_id);
      TerminateUser(in  u uid);
      TerminateSeat(in  s seat_id);
      SetUserLinger(in  u uid,
                    in  b enable,
                    in  b interactive);
      AttachDevice(in  s seat_id,
                   in  s sysfs_path,
                   in  b interactive);
      FlushDevices(in  b interactive);
      PowerOff(in  b interactive);
      PowerOffWithFlags(in  t flags);
      Reboot(in  b interactive);
      RebootWithFlags(in  t flags);
      Halt(in  b interactive);
      HaltWithFlags(in  t flags);
      Suspend(in  b interactive);
      SuspendWithFlags(in  t flags);
      Hibernate(in  b interactive);
      HibernateWithFlags(in  t flags);
      HybridSleep(in  b interactive);
      HybridSleepWithFlags(in  t flags);
      SuspendThenHibernate(in  b interactive);
      SuspendThenHibernateWithFlags(in  t flags);
      CanPowerOff(out s result);
      CanReboot(out s result);
      CanHalt(out s result);
      CanSuspend(out s result);
      CanHibernate(out s result);
      CanHybridSleep(out s result);
      CanSuspendThenHibernate(out s result);
      ScheduleShutdown(in  s type,
                       in  t usec);
      CancelScheduledShutdown(out b cancelled);
      Inhibit(in  s what,
              in  s who,
              in  s why,
              in  s mode,
              out h pipe_fd);
      CanRebootParameter(out s result);
      SetRebootParameter(in  s parameter);
      CanRebootToFirmwareSetup(out s result);
      SetRebootToFirmwareSetup(in  b enable);
      CanRebootToBootLoaderMenu(out s result);
      SetRebootToBootLoaderMenu(in  t timeout);
      CanRebootToBootLoaderEntry(out s result);
      SetRebootToBootLoaderEntry(in  s boot_loader_entry);
      SetWallMessage(in  s wall_message,
                     in  b enable);
    signals:
      SessionNew(s session_id,
                 o object_path);
      SessionRemoved(s session_id,
                     o object_path);
      UserNew(u uid,
              o object_path);
      UserRemoved(u uid,
                  o object_path);
      SeatNew(s seat_id,
              o object_path);
      SeatRemoved(s seat_id,
                  o object_path);
      PrepareForShutdown(b start);
      PrepareForSleep(b start);
    properties:
      @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
      @org.freedesktop.systemd1.Privileged("true")
      readwrite b EnableWallMessages = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
      @org.freedesktop.systemd1.Privileged("true")
      readwrite s WallMessage = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
      readonly u NAutoVTs = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
      readonly as KillOnlyUsers = [..., ...];
      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
      readonly as KillExcludeUsers = [..., ...];
      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
      readonly b KillUserProcesses = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
      readonly s RebootParameter = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
      readonly b RebootToFirmwareSetup = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
      readonly t RebootToBootLoaderMenu = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
      readonly s RebootToBootLoaderEntry = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
      readonly as BootLoaderEntries = [..., ...];
      readonly b IdleHint = ...;
      readonly t IdleSinceHint = ...;
      readonly t IdleSinceHintMonotonic = ...;
      readonly s BlockInhibited = ...;
      readonly s DelayInhibited = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
      readonly t InhibitDelayMaxUSec = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
      readonly t UserStopDelayUSec = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
      readonly s HandlePowerKey = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
      readonly s HandleSuspendKey = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
      readonly s HandleHibernateKey = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
      readonly s HandleLidSwitch = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
      readonly s HandleLidSwitchExternalPower = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
      readonly s HandleLidSwitchDocked = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
      readonly t HoldoffTimeoutUSec = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
      readonly s IdleAction = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
      readonly t IdleActionUSec = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
      readonly b PreparingForShutdown = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
      readonly b PreparingForSleep = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
      readonly (st) ScheduledShutdown = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
      readonly b Docked = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
      readonly b LidClosed = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
      readonly b OnExternalPower = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
      readonly b RemoveIPC = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
      readonly t RuntimeDirectorySize = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
      readonly t RuntimeDirectoryInodesMax = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
      readonly t InhibitorsMax = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
      readonly t NCurrentInhibitors = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
      readonly t SessionsMax = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
      readonly t NCurrentSessions = ...;
  };
  interface org.freedesktop.DBus.Peer { ... };
  interface org.freedesktop.DBus.Introspectable { ... };
  interface org.freedesktop.DBus.Properties { ... };
};
    </code></pre>
<p>.RE</p>
<h2>Methods</h2>
<p><strong>GetSession()</strong> may be used to get the session object path for the session with the specified ID. Similarly, <strong>GetUser()</strong> and <strong>GetSeat()</strong> get the user and seat objects, respectively. <strong>GetSessionByPID()</strong> and <strong>GetUserByPID()</strong> get the session/user object the specified PID belongs to if there is any.</p>
<p><strong>ListSessions()</strong> returns an array of all current sessions. The structures in the array consist of the following fields: session id, user id, user name, seat id, session object path. If a session does not have a seat attached, the seat id field will be an empty string.</p>
<p><strong>ListUsers()</strong> returns an array of all currently logged in users. The structures in the array consist of the following fields: user id, user name, user object path.</p>
<p><strong>ListSeats()</strong> returns an array of all currently available seats. The structure in the array consists of the following fields: seat id, seat object path.</p>
<p><strong>ListInhibitors()</strong> lists all currently active inhibitors. It returns an array of structures consisting of <code>what</code>, <code>who</code>, <code>why</code>, <code>mode</code>, <code>uid</code> (user ID), and <code>pid</code> (process ID).</p>
<p><strong>CreateSession()</strong> and <strong>ReleaseSession()</strong> may be used to open or close login sessions. These calls should <code>never</code> be invoked directly by clients. Creating/closing sessions is exclusively the job of PAM and its <a href='/8/pam_systemd'>pam_systemd</a>(8) module.</p>
<p><strong>ActivateSession()</strong> brings the session with the specified ID into the foreground. <strong>ActivateSessionOnSeat()</strong> does the same, but only if the seat id matches.</p>
<p><strong>LockSession()</strong> asks the session with the specified ID to activate the screen lock. <strong>UnlockSession()</strong> asks the session with the specified ID to remove an active screen lock, if there is any. This is implemented by sending out the Lock() and Unlock() signals from the respective session object which session managers are supposed to listen on.</p>
<p><strong>LockSessions()</strong> asks all sessions to activate their screen locks. This may be used to lock access to the entire machine in one action. Similarly, <strong>UnlockSessions()</strong> asks all sessions to deactivate their screen locks.</p>
<p><strong>KillSession()</strong> may be used to send a Unix signal to one or all processes of a session. As arguments it takes the session id, either the string "leader" or "all" and a signal number. If "leader" is passed only the session "leader" is killed. If "all" is passed all processes of the session are killed.</p>
<p><strong>KillUser()</strong> may be used to send a Unix signal to all processes of a user. As arguments it takes the user id and a signal number.</p>
<p><strong>TerminateSession()</strong>, <strong>TerminateUser()</strong>, <strong>TerminateSeat()</strong> may be used to forcibly terminate one specific session, all processes of a user, and all sessions attached to a specific seat, respectively. The session, user, and seat are identified by their respective IDs.</p>
<p><strong>SetUserLinger()</strong> enables or disables user lingering. If enabled, the runtime directory of a user is kept around and they may continue to run processes while logged out. If disabled, the runtime directory goes away as soon as they log out. <strong>SetUserLinger()</strong> expects three arguments: the UID, a boolean whether to enable/disable and a boolean controlling the <strong>polkit</strong>[1] authorization interactivity (see below). Note that the user linger state is persistently stored on disk.</p>
<p><strong>AttachDevice()</strong> may be used to assign a specific device to a specific seat. The device is identified by its /sys/ path and must be eligible for seat assignments. <strong>AttachDevice()</strong> takes three arguments: the seat id, the sysfs path, and a boolean for controlling polkit interactivity (see below). Device assignments are persistently stored on disk. To create a new seat, simply specify a previously unused seat id. For more information about the seat assignment logic see <a href='/3/sd-login'>sd-login</a>(3).</p>
<p><strong>FlushDevices()</strong> removes all explicit seat assignments for devices, resetting all assignments to the automatic defaults. The only argument it takes is the polkit interactivity boolean (see below).</p>
<p><strong>PowerOff()</strong>, <strong>Reboot()</strong>, <strong>Halt()</strong>, <strong>Suspend()</strong>, and <strong>Hibernate()</strong> result in the system being powered off, rebooted, halted (shut down without turning off power), suspended (the system state is saved to RAM and the CPU is turned off), or hibernated (the system state is saved to disk and the machine is powered down). <strong>HybridSleep()</strong> results in the system entering a hybrid-sleep mode, i.e. the system is both hibernated and suspended. <strong>SuspendThenHibernate()</strong> results in the system being suspended, then later woken using an RTC timer and hibernated. The only argument is the polkit interactivity boolean <code>interactive</code> (see below). The main purpose of these calls is that they enforce polkit policy and hence allow powering off/rebooting/suspending/hibernating even by unprivileged users. They also enforce inhibition locks for non-privileged users. UIs should expose these calls as the primary mechanism to poweroff/reboot/suspend/hibernate the machine. Methods <strong>PowerOffWithFlags()</strong>, <strong>RebootWithFlags()</strong>, <strong>HaltWithFlags()</strong>, <strong>SuspendWithFlags()</strong>, <strong>HibernateWithFlags()</strong>, <strong>HybridSleepWithFlags()</strong> and <strong>SuspendThenHibernateWithFlags()</strong> add <code>flags</code> to allow for extendability, defined as follows:</p>
<p>.RS 4</p>
<pre><code>#define SD_LOGIND_ROOT_CHECK_INHIBITORS  (UINT64_C(1) &lt;&lt; 0)
#define SD_LOGIND_KEXEC_REBOOT           (UINT64_C(1) &lt;&lt; 1)
      </code></pre>
<p>.RE</p>
<p>When the <code>flags</code> is 0 then these methods behave just like the versions without flags. When <strong>SD_LOGIND_ROOT_CHECK_INHIBITORS</strong> (0x01) is set, active inhibitors are honoured for privileged users too. When <strong>SD_LOGIND_KEXEC_REBOOT</strong> (0x02) is set, then <strong>RebootWithFlags()</strong> perform kexec reboot if kexec kernel is loaded.</p>
<p><strong>SetRebootParameter()</strong> sets a parameter for a subsequent reboot operation. See the description of <strong>reboot</strong> in <a href='/1/systemctl'>systemctl</a>(1) and <a href='/2/reboot'>reboot</a>(2) for more information.</p>
<p><strong>SetRebootToFirmwareSetup()</strong>, <strong>SetRebootToBootLoaderMenu()</strong>, and <strong>SetRebootToBootLoaderEntry()</strong> configure the action to be taken from the boot loader after a reboot: respectively entering firmware setup mode, the boot loader menu, or a specific boot loader entry. See <a href='/1/systemctl'>systemctl</a>(1) for the corresponding command line interface.</p>
<p><strong>CanPowerOff()</strong>, <strong>CanReboot()</strong>, <strong>CanHalt()</strong>, <strong>CanSuspend()</strong>, <strong>CanHibernate()</strong>, <strong>CanHybridSleep()</strong>, <strong>CanSuspendThenHibernate()</strong>, <strong>CanRebootParameter()</strong>, <strong>CanRebootToFirmwareSetup()</strong>, <strong>CanRebootToBootLoaderMenu()</strong>, and <strong>CanRebootToBootLoaderEntry()</strong> test whether the system supports the respective operation and whether the calling user is allowed to execute it. Returns one of "na", "yes", "no", and "challenge". If "na" is returned, the operation is not available because hardware, kernel, or drivers do not support it. If "yes" is returned, the operation is supported and the user may execute the operation without further authentication. If "no" is returned, the operation is available but the user is not allowed to execute the operation. If "challenge" is returned, the operation is available but only after authorization.</p>
<p><strong>ScheduleShutdown()</strong> schedules a shutdown operation <code>type</code> at time <code>usec</code> in microseconds since the UNIX epoch. <code>type</code> can be one of "poweroff", "dry-poweroff", "reboot", "dry-reboot", "halt", and "dry-halt". (The "dry-" variants do not actually execute the shutdown action.) <strong>CancelScheduledShutdown()</strong> cancels a scheduled shutdown. The output parameter <code>cancelled</code> is true if a shutdown operation was scheduled.</p>
<p><strong>SetWallMessage()</strong> sets the wall message (the message that will be sent out to all terminals and stored in a <a href='/5/utmp'>utmp</a>(5) record) for a subsequent scheduled shutdown operation. The parameter <code>wall_message</code> specifies the shutdown reason (and may be empty) which will be included in the shutdown message. The parameter <code>enable</code> specifies whether to print a wall message on shutdown.</p>
<p><strong>Inhibit()</strong> creates an inhibition lock. It takes four parameters: <code>what</code>, <code>who</code>, <code>why</code>, and <code>mode</code>. <code>what</code> is one or more of "shutdown", "sleep", "idle", "handle-power-key", "handle-suspend-key", "handle-hibernate-key", "handle-lid-switch", separated by colons, for inhibiting poweroff/reboot, suspend/hibernate, the automatic idle logic, or hardware key handling. <code>who</code> should be a short human readable string identifying the application taking the lock. <code>why</code> should be a short human readable string identifying the reason why the lock is taken. Finally, <code>mode</code> is either "block" or "delay" which encodes whether the inhibit shall be consider mandatory or whether it should just delay the operation to a certain maximum time. The method returns a file descriptor. The lock is released the moment this file descriptor and all its duplicates are closed. For more information on the inhibition logic see <strong>Inhibitor Locks</strong>[2].</p>
<h2>Signals</h2>
<p>Whenever the inhibition state or idle hint changes, <strong>PropertyChanged</strong> signals are sent out to which clients can subscribe.</p>
<p>The <strong>SessionNew</strong>, <strong>SessionRemoved</strong>, <strong>UserNew</strong>, <strong>UserRemoved</strong>, <strong>SeatNew</strong>, and <strong>SeatRemoved</strong> signals are sent each time a session is created or removed, a user logs in or out, or a seat is added or removed. They each contain the ID of the object plus the object path.</p>
<p>The <strong>PrepareForShutdown()</strong> and <strong>PrepareForSleep()</strong> signals are sent right before (with the argument "true") or after (with the argument "false") the system goes down for reboot/poweroff and suspend/hibernate, respectively. This may be used by applications to save data on disk, release memory, or do other jobs that should be done shortly before shutdown/sleep, in conjunction with delay inhibitor locks. After completion of this work they should release their inhibition locks in order to not delay the operation any further. For more information see <strong>Inhibitor Locks</strong>[2].</p>
<h2>Properties</h2>
<p>Most properties simply reflect the configuration, see <a href='/5/logind.conf'>logind.conf</a>(5). This includes: <code>NAutoVTs</code>, <code>KillOnlyUsers</code>, <code>KillExcludeUsers</code>, <code>KillUserProcesses</code>, <code>IdleAction</code>, <code>InhibitDelayMaxUSec</code>, <code>InhibitorsMax</code>, <code>UserStopDelayUSec</code>, <code>HandlePowerKey</code>, <code>HandleSuspendKey</code>, <code>HandleHibernateKey</code>, <code>HandleLidSwitch</code>, <code>HandleLidSwitchExternalPower</code>, <code>HandleLidSwitchDocked</code>, <code>IdleActionUSec</code>, <code>HoldoffTimeoutUSec</code>, <code>RemoveIPC</code>, <code>RuntimeDirectorySize</code>, <code>RuntimeDirectoryInodesMax</code>, <code>InhibitorsMax</code>, and <code>SessionsMax</code>.</p>
<p>The <code>IdleHint</code> property reflects the idle hint state of the system. If the system is idle it might get into automatic suspend or shutdown depending on the configuration.</p>
<p><code>IdleSinceHint</code> and <code>IdleSinceHintMonotonic</code> encode the timestamps of the last change of the idle hint boolean, in <strong>CLOCK_REALTIME</strong> and <strong>CLOCK_MONOTONIC</strong> timestamps, respectively, in microseconds since the epoch.</p>
<p>The <code>BlockInhibited</code> and <code>DelayInhibited</code> properties encode the currently active locks of the respective modes. They are colon separated lists of "shutdown", "sleep", and "idle" (see above).</p>
<p><code>NCurrentSessions</code> and <code>NCurrentInhibitors</code> contain the number of currently registered sessions and inhibitors.</p>
<p>The <code>BootLoaderEntries</code> property contains a list of boot loader entries. This includes boot loader entries defined in configuration and any additional loader entries reported by the boot loader. See <a href='/7/systemd-boot'>systemd-boot</a>(7) for more information.</p>
<p>The <code>PreparingForShutdown</code> and <code>PreparingForSleep</code> boolean properties are true during the interval between the two <strong>PrepareForShutdown</strong> and <strong>PrepareForSleep</strong> signals respectively. Note that these properties do not send out <strong>PropertyChanged</strong> signals.</p>
<p>The <code>RebootParameter</code> property shows the value set with the <strong>SetRebootParameter()</strong> method described above.</p>
<p><code>ScheduledShutdown</code> shows the value pair set with the <strong>ScheduleShutdown()</strong> method described above.</p>
<p><code>RebootToFirmwareSetup</code>, <code>RebootToBootLoaderMenu</code>, and <code>RebootToBootLoaderEntry</code> are true when the resprective post-reboot operation was selected with <strong>SetRebootToFirmwareSetup</strong>, <strong>SetRebootToBootLoaderMenu</strong>, or <strong>SetRebootToBootLoaderEntry</strong>.</p>
<p>The <code>WallMessage</code> and <code>EnableWallMessages</code> properties reflect the shutdown reason and wall message enablement switch which can be set with the <strong>SetWallMessage()</strong> method described above.</p>
<p><code>Docked</code> is true if the machine is connected to a dock. <code>LidClosed</code> is true when the lid (of a laptop) is closed. <code>OnExternalPower</code> is true when the machine is connected to an external power supply.</p>
<h2>Security</h2>
<p>A number of operations are protected via the polkit privilege system. <strong>SetUserLinger()</strong> requires the org.freedesktop.login1.set-user-linger privilege. <strong>AttachDevice()</strong> requires org.freedesktop.login1.attach-device and <strong>FlushDevices()</strong> requires org.freedesktop.login1.flush-devices. <strong>PowerOff()</strong>, <strong>Reboot()</strong>, <strong>Halt()</strong>, <strong>Suspend()</strong>, <strong>Hibernate()</strong> require org.freedesktop.login1.power-off, org.freedesktop.login1.power-off-multiple-sessions, org.freedesktop.login1.power-off-ignore-inhibit, org.freedesktop.login1.reboot, org.freedesktop.login1.reboot-multiple-sessions, org.freedesktop.login1.reboot-ignore-inhibit, org.freedesktop.login1.halt, org.freedesktop.login1.halt-multiple-sessions, org.freedesktop.login1.halt-ignore-inhibit, org.freedesktop.login1.suspend, org.freedesktop.login1.suspend-multiple-sessions, org.freedesktop.login1.suspend-ignore-inhibit, org.freedesktop.login1.hibernate, org.freedesktop.login1.hibernate-multiple-sessions, org.freedesktop.login1.hibernate-ignore-inhibit, respectively depending on whether there are other sessions around or active inhibits are present. <strong>HybridSleep()</strong> and <strong>SuspendThenHibernate()</strong> use the same privileges as <strong>Hibernate()</strong>. <strong>SetRebootParameter()</strong> requires org.freedesktop.login1.set-reboot-parameter.</p>
<p><strong>SetRebootToFirmwareSetup</strong> requires org.freedesktop.login1.set-reboot-to-firmware-setup. <strong>SetRebootToBootLoaderMenu</strong> requires org.freedesktop.login1.set-reboot-to-boot-loader-menu. <strong>SetRebootToBootLoaderEntry</strong> requires org.freedesktop.login1.set-reboot-to-boot-loader-entry.</p>
<p><strong>ScheduleShutdown</strong> and <strong>CancelScheduledShutdown</strong> require the same privileges (listed above) as the immediate poweroff/reboot/halt operations.</p>
<p><strong>Inhibit()</strong> is protected via one of org.freedesktop.login1.inhibit-block-shutdown, org.freedesktop.login1.inhibit-delay-shutdown, org.freedesktop.login1.inhibit-block-sleep, org.freedesktop.login1.inhibit-delay-sleep, org.freedesktop.login1.inhibit-block-idle, org.freedesktop.login1.inhibit-handle-power-key, org.freedesktop.login1.inhibit-handle-suspend-key, org.freedesktop.login1.inhibit-handle-hibernate-key, org.freedesktop.login1.inhibit-handle-lid-switch depending on the lock type and mode taken.</p>
<p>The <code>interactive</code> boolean parameters can be used to control whether polkit should interactively ask the user for authentication credentials if required.</p>
</div></div></div><h1 id='seat-objects'><a href='#seat-objects'>SEAT OBJECTS</a></h1><div data-for='seat-objects' data-hide><div class='section' data-for='seat-objects'><div data-more>
<p>.RS 4</p>
<pre><code>node /org/freedesktop/login1/seat/seat0 {
  interface org.freedesktop.login1.Seat {
    methods:
      Terminate();
      ActivateSession(in  s session_id);
      SwitchTo(in  u vtnr);
      SwitchToNext();
      SwitchToPrevious();
    properties:
      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
      readonly s Id = ...;
      readonly (so) ActiveSession = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
      readonly b CanTTY = ...;
      readonly b CanGraphical = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
      readonly a(so) Sessions = [...];
      readonly b IdleHint = ...;
      readonly t IdleSinceHint = ...;
      readonly t IdleSinceHintMonotonic = ...;
  };
  interface org.freedesktop.DBus.Peer { ... };
  interface org.freedesktop.DBus.Introspectable { ... };
  interface org.freedesktop.DBus.Properties { ... };
};
    </code></pre>
<p>.RE</p>
<h2>Methods</h2>
<p><strong>Terminate()</strong> and <strong>ActivateSession()</strong> work similar to TerminateSeat(), ActivationSessionOnSeat() on the Manager object.</p>
<p><strong>SwitchTo()</strong> switches to the session on the virtual terminal <code>vtnr</code>. <strong>SwitchToNext()</strong> and <strong>SwitchToPrevious()</strong> switch to, respectively, the next and previous sessions on the seat in the order of virtual terminals. If there is no active session, they switch to, respectively, the first and last session on the seat.</p>
<h2>Signals</h2>
<p>Whenever <strong>ActiveSession</strong>, <strong>Sessions</strong>, <strong>CanGraphical</strong>, <strong>CanTTY</strong>, or the idle state changes, <strong>PropertyChanged</strong> signals are sent out to which clients can subscribe.</p>
<h2>Properties</h2>
<p>The <code>Id</code> property encodes the ID of the seat.</p>
<p><code>ActiveSession</code> encodes the currently active session if there is one. It is a structure consisting of the session id and the object path.</p>
<p><code>CanTTY</code> encodes whether the session is suitable for text logins, and <code>CanGraphical</code> whether it is suitable for graphical sessions.</p>
<p>The <code>Sessions</code> property is an array of all current sessions of this seat, each encoded in a structure consisting of the ID and the object path.</p>
<p>The <code>IdleHint</code>, <code>IdleSinceHint</code>, and <code>IdleSinceHintMonotonic</code> properties encode the idle state, similar to the ones exposed on the Manager object, but specific for this seat.</p>
</div></div></div><h1 id='user-objects'><a href='#user-objects'>USER OBJECTS</a></h1><div data-for='user-objects' data-hide><div class='section' data-for='user-objects'><div data-more>
<p>.RS 4</p>
<pre><code>node /org/freedesktop/login1/user/_1000 {
  interface org.freedesktop.login1.User {
    methods:
      Terminate();
      Kill(in  i signal_number);
    properties:
      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
      readonly u UID = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
      readonly u GID = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
      readonly s Name = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
      readonly t Timestamp = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
      readonly t TimestampMonotonic = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
      readonly s RuntimePath = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
      readonly s Service = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
      readonly s Slice = ...;
      readonly (so) Display = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
      readonly s State = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
      readonly a(so) Sessions = [...];
      readonly b IdleHint = ...;
      readonly t IdleSinceHint = ...;
      readonly t IdleSinceHintMonotonic = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
      readonly b Linger = ...;
  };
  interface org.freedesktop.DBus.Peer { ... };
  interface org.freedesktop.DBus.Introspectable { ... };
  interface org.freedesktop.DBus.Properties { ... };
};
    </code></pre>
<p>.RE</p>
<h2>Methods</h2>
<p><strong>Terminate()</strong> and <strong>Kill()</strong> work similar to the <strong>TerminateUser()</strong> and <strong>KillUser()</strong> methods on the manager object.</p>
<h2>Signals</h2>
<p>Whenever <code>Sessions</code> or the idle state changes, <strong>PropertyChanged</strong> signals are sent out to which clients can subscribe.</p>
<h2>Properties</h2>
<p>The <code>UID</code> and <code>GID</code> properties encode the Unix UID and primary GID of the user.</p>
<p>The <code>Name</code> property encodes the user name.</p>
<p><code>Timestamp</code> and <code>TimestampMonotonic</code> encode the login time of the user in microseconds since the epoch, in the <strong>CLOCK_REALTIME</strong> and <strong>CLOCK_MONOTONIC</strong> clocks, respectively.</p>
<p><code>RuntimePath</code> encodes the runtime path of the user, i.e. <code>$XDG_RUNTIME_DIR</code>. For details see the <strong>XDG Basedir Specification</strong>[3].</p>
<p><code>Service</code> contains the unit name of the user systemd service of this user. Each logged in user is assigned a user service that runs a user systemd instance. This is usually an instance of user@.service.</p>
<p><code>Slice</code> contains the unit name of the user systemd slice of this user. Each logged in user gets a private slice.</p>
<p><code>Display</code> encodes which graphical session should be used as the primary UI display for the user. It is a structure encoding the session ID and the object path of the session to use.</p>
<p><code>State</code> encodes the user state and is one of "offline", "lingering", "online", "active", or "closing". See <a href='/3/sd_uid_get_state'>sd_uid_get_state</a>(3) for more information about the states.</p>
<p><code>Sessions</code> is an array of structures encoding all current sessions of the user. Each structure consists of the ID and object path.</p>
<p>The <code>IdleHint</code>, <code>IdleSinceHint</code>, and <code>IdleSinceHintMonotonic</code> properties encode the idle hint state of the user, similar to the Managers properties, but specific for this user.</p>
<p>The <code>Linger</code> property shows whether lingering is enabled for this user.</p>
</div></div></div><h1 id='session-objects'><a href='#session-objects'>SESSION OBJECTS</a></h1><div data-for='session-objects' data-hide><div class='section' data-for='session-objects'><div data-more>
<p>.RS 4</p>
<pre><code>node /org/freedesktop/login1/session/1 {
  interface org.freedesktop.login1.Session {
    methods:
      Terminate();
      Activate();
      Lock();
      Unlock();
      SetIdleHint(in  b idle);
      SetLockedHint(in  b locked);
      Kill(in  s who,
           in  i signal_number);
      TakeControl(in  b force);
      ReleaseControl();
      SetType(in  s type);
      TakeDevice(in  u major,
                 in  u minor,
                 out h fd,
                 out b inactive);
      ReleaseDevice(in  u major,
                    in  u minor);
      PauseDeviceComplete(in  u major,
                          in  u minor);
      SetBrightness(in  s subsystem,
                    in  s name,
                    in  u brightness);
    signals:
      PauseDevice(u major,
                  u minor,
                  s type);
      ResumeDevice(u major,
                   u minor,
                   h fd);
      Lock();
      Unlock();
    properties:
      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
      readonly s Id = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
      readonly (uo) User = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
      readonly s Name = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
      readonly t Timestamp = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
      readonly t TimestampMonotonic = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
      readonly u VTNr = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
      readonly (so) Seat = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
      readonly s TTY = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
      readonly s Display = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
      readonly b Remote = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
      readonly s RemoteHost = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
      readonly s RemoteUser = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
      readonly s Service = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
      readonly s Desktop = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
      readonly s Scope = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
      readonly u Leader = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
      readonly u Audit = ...;
      readonly s Type = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
      readonly s Class = ...;
      readonly b Active = ...;
      readonly s State = ...;
      readonly b IdleHint = ...;
      readonly t IdleSinceHint = ...;
      readonly t IdleSinceHintMonotonic = ...;
      readonly b LockedHint = ...;
  };
  interface org.freedesktop.DBus.Peer { ... };
  interface org.freedesktop.DBus.Introspectable { ... };
  interface org.freedesktop.DBus.Properties { ... };
};
    </code></pre>
<p>.RE</p>
<h2>Methods</h2>
<p><strong>Terminate()</strong>, <strong>Activate()</strong>, <strong>Lock()</strong>, <strong>Unlock()</strong>, and <strong>Kill()</strong> work similarly to the respective calls on the Manager object.</p>
<p><strong>SetIdleHint()</strong> is called by the session object to update the idle state of the session whenever it changes.</p>
<p><strong>TakeControl()</strong> allows a process to take exclusive managed device access-control for that session. Only one D-Bus connection can be a controller for a given session at any time. If the <code>force</code> argument is set (root only), an existing controller is kicked out and replaced. Otherwise, this method fails if there is already a controller. Note that this method is limited to D-Bus users with the effective UID set to the user of the session or root.</p>
<p><strong>ReleaseControl()</strong> drops control of a given session. Closing the D-Bus connection implicitly releases control as well. See <strong>TakeControl()</strong> for more information. This method also releases all devices for which the controller requested ownership via <strong>TakeDevice()</strong>.</p>
<p><strong>SetType()</strong> allows the type of the session to be changed dynamically. It can only be called by sessions current controller. If <strong>TakeControl()</strong> has not been called, this method will fail. In addition, the session type will be reset to its original value once control is released, either by calling <strong>ReleaseControl()</strong> or closing the D-Bus connection. This should help prevent a session from entering an inconsistent state, for example if the controller crashes. The only argument <code>type</code> is the new session type.</p>
<p><strong>TakeDevice()</strong> allows a session controller to get a file descriptor for a specific device. Pass in the major and minor numbers of the character device and systemd-logind will return a file descriptor for the device. Only a limited set of device-types is currently supported (but may be extended). systemd-logind automatically mutes the file descriptor if the session is inactive and resumes it once the session is activated again. This guarantees that a session can only access session devices if the session is active. Note that this revoke/resume mechanism is asynchronous and may happen at any given time. This only works on devices that are attached to the seat of the given session. A process is not required to have direct access to the device node. systemd-logind only requires you to be the active session controller (see <strong>TakeControl()</strong>). Also note that any device can only be requested once. As long as you dont release it, further <strong>TakeDevice()</strong> calls will fail.</p>
<p><strong>ReleaseDevice()</strong> releases a device again (see <strong>TakeDevice()</strong>). This is also implicitly done by <strong>ReleaseControl()</strong> or when closing the D-Bus connection.</p>
<p><strong>PauseDeviceComplete()</strong> allows a session controller to synchronously pause a device after receiving a <strong>PauseDevice("pause")</strong> signal. Forced signals (or after an internal timeout) are automatically completed by systemd-logind asynchronously.</p>
<p><strong>SetLockedHint()</strong> may be used to set the "locked hint" to <code>locked</code>, i.e. information whether the session is locked. This is intended to be used by the desktop environment to tell <strong>systemd-logind</strong> when the session is locked and unlocked.</p>
<p><strong>SetBrightness()</strong> may be used to set the display brightness. This is intended to be used by the desktop environment and allows unprivileged programs to access hardware settings in a controlled way. The <code>subsystem</code> parameter specifies a kernel subsystem, either "backlight" or "leds". The <code>name</code> parameter specifies a device name under the specified subsystem. The <code>brightness</code> parameter specifies the brightness. The range is defined by individual drivers, see /sys/class/<code>subsystem</code>/<code>name</code>/max_brightness.</p>
<h2>Signals</h2>
<p>The active session controller exclusively gets <strong>PauseDevice</strong> and <strong>ResumeDevice</strong> events for any device it requested via <strong>TakeDevice()</strong>. They notify the controller whenever a device is paused or resumed. A device is never resumed if its session is inactive. Also note that <strong>PauseDevice</strong> signals are sent before the <strong>PropertyChanged</strong> signal for the <strong>Active</strong> state. The inverse is true for <strong>ResumeDevice</strong>. A device may remain paused for unknown reasons even though the Session is active.</p>
<p>A <strong>PauseDevice</strong> signal carries the major and minor numbers and a string describing the type as arguments. <strong>force</strong> means the device was already paused by systemd-logind and the signal is only an asynchronous notification. <strong>pause</strong> means systemd-logind grants you a limited amount of time to pause the device. You must respond to this via <strong>PauseDeviceComplete()</strong>. This synchronous pausing mechanism is used for backwards-compatibility to VTs and systemd-logind is free to not make use of it. It is also free to send a forced <strong>PauseDevice</strong> if you dont respond in a timely manner (or for any other reason). <strong>gone</strong> means the device was unplugged from the system and you will no longer get any notifications about it. There is no need to call <strong>ReleaseDevice()</strong>. You may call <strong>TakeDevice()</strong> again if a new device is assigned the major+minor combination.</p>
<p><strong>ResumeDevice</strong> is sent whenever a session is active and a device is resumed. It carries the major/minor numbers as arguments and provides a new open file descriptor. You should switch to the new descriptor and close the old one. They are not guaranteed to have the same underlying open file descriptor in the kernel (except for a limited set of device types).</p>
<p>Whenever <strong>Active</strong> or the idle state changes, <strong>PropertyChanged</strong> signals are sent out to which clients can subscribe.</p>
<p><strong>Lock</strong>/<strong>Unlock</strong> is sent when the session is asked to be screen-locked/unlocked. A session manager of the session should listen to this signal and act accordingly. This signal is sent out as a result of the <strong>Lock()</strong> and <strong>Unlock()</strong> methods, respectively.</p>
<h2>Properties</h2>
<p><code>Id</code> encodes the session ID.</p>
<p><code>User</code> encodes the user ID of the user this session belongs to. This is a structure consisting of the Unix UID and the object path.</p>
<p><code>Name</code> encodes the user name.</p>
<p><code>Timestamp</code> and <code>TimestampMonotonic</code> encode the microseconds since the epoch when the session was created, in <strong>CLOCK_REALTIME</strong> or <strong>CLOCK_MONOTONIC</strong>, respectively.</p>
<p><code>VTNr</code> encodes the virtual terminal number of the session if there is any, 0 otherwise.</p>
<p><code>Seat</code> encodes the seat this session belongs to if there is any. This is a structure consisting of the ID and the seat object path.</p>
<p><code>TTY</code> encodes the kernel TTY path of the session if this is a text login. If not this is an empty string.</p>
<p><code>Display</code> encodes the X11 display name if this is a graphical login. If not, this is an empty string.</p>
<p><code>Remote</code> encodes whether the session is local or remote.</p>
<p><code>RemoteHost</code> and <code>RemoteUser</code> encode the remote host and user if this is a remote session, or an empty string otherwise.</p>
<p><code>Service</code> encodes the PAM service name that registered the session.</p>
<p><code>Desktop</code> describes the desktop environment running in the session (if known).</p>
<p><code>Scope</code> contains the systemd scope unit name of this session.</p>
<p><code>Leader</code> encodes the PID of the process that registered the session.</p>
<p><code>Audit</code> encodes the Kernel Audit session ID of the session if auditing is available.</p>
<p><code>Type</code> encodes the session type. Its one of "unspecified" (for cron PAM sessions and suchlike), "tty" (for text logins) or "x11"/"mir"/"wayland" (for graphical logins).</p>
<p><code>Class</code> encodes the session class. Its one of "user" (for normal user sessions), "greeter" (for display manager pseudo-sessions), or "lock-screen" (for display lock screens).</p>
<p><code>Active</code> is a boolean that is true if the session is active, i.e. currently in the foreground. This field is semi-redundant due to <code>State</code>.</p>
<p><code>State</code> encodes the session state and one of "online", "active", or "closing". See <a href='/3/sd_session_get_state'>sd_session_get_state</a>(3) for more information about the states.</p>
<p><code>IdleHint</code>, <code>IdleSinceHint</code>, and <code>IdleSinceHintMonotonic</code> encapsulate the idle hint state of this session, similarly to how the respective properties on the manager object do it for the whole system.</p>
<p><code>LockedHint</code> shows the locked hint state of this session, as set by the <strong>SetLockedHint()</strong> method described above.</p>
</div></div></div><h1 id='examples'><a href='#examples'>EXAMPLES</a></h1><div class='section' data-for='examples'><div data-more>
<p><strong>Example 1. Introspect org.freedesktop.login1.Manager on the bus</strong></p>
<p>.RS 4</p>
<pre><code>$ gdbus introspect --system --dest org.freedesktop.login1 \
  --object-path /org/freedesktop/login1
      </code></pre>
<p>.RE</p>
<p><strong>Example 2. Introspect org.freedesktop.login1.Seat on the bus</strong></p>
<p>.RS 4</p>
<pre><code>$ gdbus introspect --system --dest org.freedesktop.login1 \
 --object-path /org/freedesktop/login1/seat/seat0
      </code></pre>
<p>.RE</p>
<p><strong>Example 3. Introspect org.freedesktop.login1.User on the bus</strong></p>
<p>.RS 4</p>
<pre><code>$ gdbus introspect --system --dest org.freedesktop.login1 \
  --object-path /org/freedesktop/login1/user/_1000
      </code></pre>
<p>.RE</p>
<p><strong>Example 4. Introspect org.freedesktop.login1.Session on the bus</strong></p>
<p>.RS 4</p>
<pre><code>$ gdbus introspect --system --dest org.freedesktop.login1 \
  --object-path /org/freedesktop/login1/session/45
      </code></pre>
<p>.RE</p>
</div></div><h1 id='versioning'><a href='#versioning'>VERSIONING</a></h1><div data-for='versioning' data-hide><div class='section' data-for='versioning'><div data-more>
<p>These D-Bus interfaces follow <strong>the usual interface versioning guidelines</strong>[4].</p>
</div></div></div><h1 id='notes'><a href='#notes'>NOTES</a></h1><div data-for='notes' data-hide><div class='section' data-for='notes'><div data-more>
<ul>
<li><p>polkit</p>
<p><a href="https://www.freedesktop.org/software/polkit/docs/latest/">https://www.freedesktop.org/software/polkit/docs/latest/</a></p></li>
<li><p>Inhibitor Locks</p>
<p><a href="https://www.freedesktop.org/wiki/Software/systemd/inhibit">https://www.freedesktop.org/wiki/Software/systemd/inhibit</a></p></li>
<li><p>XDG Basedir Specification</p>
<p><a href="https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html">https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html</a></p></li>
<li><p>the usual interface versioning guidelines</p>
<p><a href="http://0pointer.de/blog/projects/versioning-dbus.html">http://0pointer.de/blog/projects/versioning-dbus.html</a></p></li>
</ul></div></div></div>


        </div>

    </body>

</html>